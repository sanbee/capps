\documentclass[12pt]{article}
%\documentstyle[12pt,amsmath]{article}
\usepackage{html}
\usepackage{epsf}
\usepackage{amsmath}
\usepackage[dvips]{graphicx, color}  % The figure package
\usepackage{palatino}
\usepackage{natbib}     % Package used for bib. citation
\usepackage{txfonts}

%\setlength{\textheight}{23.0cm}
\setlength{\textwidth}{15.00cm}
%\setlength{\topmargin}{-1.5cm}
\setlength{\oddsidemargin}{0.75cm}
\setlength{\evensidemargin}{0.5cm}
%\setlength{\parskip}{5pt}
%\setlength{\parindent}{20pt}

%\evensidemargin -0.7cm
%\oddsidemargin 1.5cm
%\textwidth 13cm
%\topmargin -1.5cm
%\textheight 23cm
%\parskip 1ex    % White space between paragraphs amount
\pagestyle{myheadings}

\begin{document}
\title{MeasurementSet Selection Syntax}
\author{S. Bhatnagar\\ NRAO, Socorro}
\date{June 15, 2007\\{\small (Updated: Sept. 03, 2009)}}
\maketitle
\normalsize
\markboth{MeasurementSet Selection Syntax}{S. Bhatnagar}
\begin{center}
  \htmladdnormallinkfoot{PDF
    Version}{http://www.aoc.nrao.edu/~sbhatnag/misc/msselection.pdf}
\end{center}

\begin{abstract}
This note describes the syntax for the various expressions for
selecting data from the Measurement Set.  This is the syntax that is
implemented in the {\tt MSSelection} module of CASA.  The syntax is
derived from an \htmladdnormallinkfoot{earlier
  note}{http://almasw.hq.eso.org/almasw/bin/view/OFFLINE/DataSelection}
on syntax definition.  All expressions consist of a comma or
semi-colon separated list of specifications.  Except channel
selection, the final product of parsing the expressions is a Table
Expression Node (TEN) which can be used to construct a selected
Measurement Set.  Higher level global methods to return a selected MS,
given the user supplied expressions, are also provided as part of the
{\tt MSSelection} module.

Error handling is done via the C++ exception handling mechanism.  The
exceptions thrown by the {\tt MSSelection} module are of type {\tt
  MSSelectionError} which is derived from {\tt AipsError} class.  The
exceptions generated from each individual expression parser are
further specializations of the {\tt MSSeletionError} class.
Application layer code therefore can have a finer level control on
error handling.
\end{abstract}

\section{General Syntax}

A MSSelection expression consists of a comma separated list of
specifications.  Specifications are typically strings or numbers.
Strings and numbers can be mixed to form a single list.  Elements of
the list which can be converted to integers are treated as integer
index specification.  Elements which do not get parsed as numbers are
treated as strings.  Where appropriate, strings are matched against
names.  Depending upon the content of a string, it can be used as
regular expressions or pattern.  Where appropriate, physical
quantities (numbers with appropriate units) can also be used.

A blank selection expression is interpreted as "no selection to be
applied to the MS".  Hence a blank expression effectively implies
"select all".

\subsection{Number format}

Integers can be of any length (in terms of characters) and composed of
the characters in the range 0-9. Where appropriate, negative values
can be given using the '-' character.  Floating point numbers can be
in the standard format:

\begin{itemize}
\item   DIGIT.DIGIT  : e.g. 10.56
\item   DIGIT.       : e.g. 10.
\item   .DIGIT       : e.g. .56
\end{itemize}
or in the mantissa-exponent format (e.g. 10.56e-1).  If a floating
point number is given where only integers are expected (e.g. indexes),
the floating point value is truncated to the nearest integer.

\subsection{Range specification}

Range of numbers (integers or real numbers) can be given in the format
N0$\sim$N1.  Integer ranges are expanded into a list of integers
starting from N0 (inclusive) to N1 (inclusive).  Range of real numbers
is used to select all values between N0 and N1 (including the
boundaries). E.g.

Integer ranges:

\begin{itemize}
\item 10$\sim$30 implies all integers in the range [10,30]
\item 10.1$\sim$30.5 implies all integers in the range [10,30]
\end{itemize}
Floating point ranges:
\begin{itemize}
\item 10$\sim$30 implies all values in the range [10.0, 30.0]
\item 10.5$\sim$30.7 implies all values in the range [10.5, 30.7]
\item 1.05e1 $\sim$ 3.07e1 implies all values in the range [10.5,
  30.7]
\end{itemize}

\subsection{Units}

Wherever appropriate, units can be optionally specified.  Values with
units are converted to the units in the Measurement Set (which uses
the MKS-system).  For ranges, the units are specified only once (at
the end) and it applies to both the range boundaries. E.g.

\begin{itemize}
\item   1421.07MHz implies 1421.07e6 Hz
\item 1421$\sim$1500MHz implies all frequencies in the range [1421.0,
  1500.0]MHz.
\end{itemize}

\subsection{Strings}

String matching can be done in three ways.  Any component of a comma
separated list that cannot be parsed as number/number range/physical
quantity is treated as a regular expression or a literal string.  If
the string does not contain the characters '*', '{', '}' or '?', it is
treated as a literal string and used for exact matching.  If any of
the above mentioned characters are part of the string, it is used as a
regular expression.  As a result, for most cases, the user does not
need to supply any special delimiters for literal strings and/or
regular expressions.  However if it is required that the string be
matched exclusively as a regular expression, it can be supplied within
a pair of '/' as delimiters.  A string enclosed within double quotes
('"') is used exclusively for pattern matching (patterns are a
simplified form of regular expressions - used in most UNIX commands
for string matching). Patterns are internally converted to equivalent
regular expressions before matching.  Read elsewhere (e.g. use command
"info regex", or visit http://www.regular-expressions.info) for
details of regular expression and patterns.

Strings can include any character except the following:

\begin{verbatim}
   ','   ';' '"'  '/'  ':' and NEWLINE
\end{verbatim}
(these are reserved characters for MSSelection expression syntax).
Strings that do not contain any of the characters used to construct
regular expressions or patterns are used for exact matches.  Although
it is highly discouraged to have name in the database containing the
above mentioned reserved characters, if one DOES choose to include the
reserved characters are part of names etc., those names can only be
matched against quoted strings (since regular expression and patterns
are super-set of literal strings. I.e. literal string is a valid
regular expression also).  This leaves the list '"', '*', '?', '{' and
  '}' as the list of printable character that cannot be part of a name
(i.e., a name containing this character can never be matched in a
MSSelection expression).  If a need is felt to include these as well,
an escape mechanism can be included later (but I would prefer to
enforce that {\bf at least} these characters not be part of any
name!).  Following are some examples of strings/regular
expressions/patterns:

\begin{itemize}
\item The string LBAND will be used as a literal string for exact
  match.  This will match only "LBAND".
   
\item The string {\tt *BAND*} will be used as a string pattern for
  matching.  This will match any string which has "BAND" in it.
 
\item The string {\tt"*BAND*"} will be used as a string pattern for
  matching.  This will also match any string which has the string
  "BAND" in it.

\item The string /.*BAND.*/ will be used as a regular expression.
  This will also match any string which has the string "BAND" in it.
  (.* operator has the same meaning as the '*' operator of patterns).
\end{itemize}

\subsection{Handling of blanks}

In most cases, blanks are treated as white-spaces (i.e., insertion of
blanks anywhere in the expression has no effect), except in the case
of Field Selection Expressions (see Section~\ref{FIELDEXPR}).  Blanks
are allowed as part of the field names.  Blanks around the delimiting
characters (',' , ';' , '\&' etc.) are ignored.  For field names,
blanks after the first valid name character and before the last valid
name character are included as part of the name.  Hence

\begin{itemize}
\item field={\tt A , B , C} is same as field={\tt A,B,C}
\item field={\tt A , BB BB , C} is same as field={\tt A,BB BB,C}
  (first name is "A", second name is "BB BB" and the third name is
  "C")
\item baseline={\tt 1 , 2 , 3 \& 4 , 5 , 6 ; 10 $\sim$ 11 \& 20 $\sim$
  30} is same as\\ baseline={\tt 1,2,3\&4,5,6;10$\sim$11\&20$\sim$30}
\end{itemize}

\section{Time selection}

Time selection expression is a comma separated list of time
specifications. Time can be specified in the format
YYYY/MM/DD/HH:MM:SS.FF.  Fields (i.e., YYYY, MM, DD, HH, MM, SS and
FF), starting from left to right, can be omitted.  Omitted fields will
be replaced by context sensitive defaults as explained below.

T0, T1 and dT in the following description are time specifications.

\subsection{Syntax}

\begin{itemize}
\item time~=~~{\tt T0$\sim$T1}

      Selects all time stamps starting from T0 to T1.  Fields missing
      in T0 are replaced by the fields in the time stamp of the first
      valid selected row in the MS.  Fields missing in T1 are replaced
      by the corresponding fields of T0 (after its defaults are set).
\item time~=~~{\tt T0}

      Selects all time stamps that are within an integration time of
      T0.  Integration time is determined from the first valid
      selected row (more rigorously, an average integration time
      should be computed).  Default settings for the missing fields of
      T0 are as described in bullet (1) above.
\item time~=~~{\tt T0+dT}

      Selects all time stamps starting from T0 and ending with time
      value given by T0+dT. Defaults of T0 are set as usual described
      in bullet (1) above.  Defaults for dT are set from the time
      corresponding to MJD=0.  I.e. dT is an specification of length
      of time from nominal "start of time" (the time stamp of the
      first valid selected row of the MS).

\item time~=~~{\tt$>$T0} 

      Selects all times greater than T0. 

\item time~=~~{\tt$<$T0} 

      Selects all times less than T0. Default settings for T0 are as
      above.
\end{itemize}

\section{Antenna/Baseline Selection}

This expression is used to perform baseline based selections.
Baseline can be specified as a pair of antenna specifications.  Since
antenna specification can itself be a list of antennas, the expression
allows a rich selection syntax which is simple for simple selections.

ANT in the description below is a comma-separated list of antenna
specifications.  A baseline specification is an single ANT, ANT
followed by an operator or a pair of ANT separated by an operator.  A
baseline expression is single baseline specification or a semi-colon
separated list of baseline specifications.

\subsection{Syntax}

\subsubsection{Antenna specification}

An ANT can be given as a single string (literal/pattern/regular
expression), single integer ID, a range of integer IDs or a comma
separated list of integers.  For VLA-specific reasons (see
Section~\ref{VLACONVENTION}), {\bf only} for antenna specifications,
integers are first converted to strings and matched against the
antenna names.  E.g.

\begin{itemize}
\item {\tt VLA:N1} corresponds to antenna named "VLA:N1".
\item {\tt 1,2,3} corresponds to antennas {\bf named} "1", "2" and
  "3".
\item {\tt 1$\sim$3} corresponds to antennas {\bf named} "1", "2" and
  "3".
\item {\tt VLA:N*} corresponds to all antennas who's name starts with
  "VLA:N".
\end{itemize}

Antenna specifications are first matched against the antenna names
(the {\tt NAME} column of the {\tt ANTENNA} sub-table of the MS).  If
no match is found, the given specification is matched against the
station name (the {\tt STATION} column of the {\tt ANTENNA} sub-table
of the MS).


\subsubsection{Baseline specification}

A baseline specification consists of an ANT, an ANT followed by an
operator or a pair of antenna specifications separated by an operator.
Operator can be one, two or three ampersands ({\tt '\&'}) -- {\tt
  '\&'} selects {\it only} cross-correlation baselines, {\tt '\&\&'}
selection cross- {\it and} auto-correlation baselines and {\tt
  '\&\&\&'} selection {\it only} auto-correlation baselines.
Formally, baseline specification is of the form {\tt
  [!]ANT[$<$OP$>$[ANT]]} (where the parts in square brackets are
optional and {\tt $<$OP$>$} can be {\tt '\&', '\&\&'} or {\tt
  '\&\&\&'}).

Possible forms of baseline specifications are tabulated in
Table~\ref{BASELINE:TAB}.

\begin{table}[h!]
\caption{Baseline specification syntax}
\label{BASELINE:TAB}
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Specification} & {\bf Meaning}\\
\hline
ANT    & Select only cross-correlation baselines between all the\\
       & antennas in ANT and {\it all} other available antennas\\
\hline
ANT\&  & Select only cross-correlation baselines between antennas\\
       & in ANT only\\
\hline
ANT1\&ANT2 & Select only cross-correlation baselines between\\
       & antennas in ANT1 and ANT2\\
\hline
ANT\&\& & Select cross- {\it and} auto-correlation baselines\\
       &between all the antennas in ANT only\\
\hline
ANT\&\&* & Select cross- {\it and} auto-correlation baselines\\
       &between all the antennas in ANT and {\it all} other\\
       &available antennas\\
\hline
ANT1\&\&ANT2 & Select cross- {\it and} auto-correlation baselines\\
       & between antennas in ANT1 and ANT2\\
\hline
ANT\&\&\&  & Select {\it only} auto-correlation baselines for\\
       &antennas in ANT\\
\hline
!ANT  & Excludes all baselines involving antennas in ANT.\\
      & ANT can be any of the above expressions\\
\hline
ANT1 ; !ANT2 & ANT1 and ANT2 can be any of the above expressions.\\
             & This selects only cross-correlation baselines\\
             & between all the antennas in ANT1 and {\it all}\\
             & other available antennas {\bf except} those involving\\ 
             & antennas in ANT2.\\ 
\hline
\end{tabular}
\end{center}
\end{table}

\subsubsection{Baseline negation operator}

The negation operator '!' can be used to exclude a baseline
specification from the final selection. {\it Note that this is a
  baseline negation operator and not an antenna negation operator}.
The negation operator applies only to the baseline specification {\it
  immediately} following it.  E.g.,

\begin{itemize}
\item baseline={\tt !15} excludes all baselines with the antenna {\bf
  named} "15"
\item baseline={\tt!1$\sim$10} excludes {\bf all} baselines involving
  the antennas {\bf named} between "1" and "10"
\item baseline={\tt !1,3,5,7,9} excludes all baselines involving
  antennas {\bf named} "1", "3", "5", "7" and "9"
\item baseline={\tt 1$\sim$10;!5} selects all baselines involving
  antennas {\bf named} between "1" and "10" {\it except} those
  involving antenna {\bf named} "5".
\end{itemize}

Note that the negation operator {\it cannot} be applied to individual
members of the antenna specification/antenna list.  E.g. the
expression {\tt "1,2,!5,8"} is syntactically incorrect.

\subsubsection{Examples}
In the most common usage, an atomic ANT selects all baselines
containing all the antennas in ANT.  ANT\& selects only baselines
between the list of antennas in the antenna specification.  ANT1\&ANT2
selects baselines between antennas in ANT1 and ANT2 only.  E.g.

\begin{itemize}
\item baseline={\tt 1,2,3} selects baseline between antennas 1, 2 and
  3 and all other antennas.
\item baseline={\tt 1,2,3\&} selects baseline between antennas 1,2 and
  3 only.
\item baseline={\tt 1,2,3 \& 4,5,6} selects baselines between antennas
  1,2,3 and 4,5,6.
\end{itemize}
Following are more examples of baseline specification using ranges and
names:
\begin{itemize}
\item baseline={\tt 1$\sim$3} same as baseline=1,2,3
\item baseline={\tt 1$\sim$3\&} same as baseline=1,2,3\&
\item baseline={\tt 1$\sim$3 \& 4$\sim$5} same as baseline={\tt
  1,2,3\&4,5,6}
\item baseline={\tt VLA:N* \& VLA:E*} selects all baselines between
  antennas with names starting with "VLA:N" and "VLA:E".
\item baseline={\tt 21;!15} selects baselines between antenna {\bf
  named} "21" and all other available antennas, {\it except} antenna
  {\bf named} "15".  I.e, baseline "21-15" (or its conjugate, if
  present in the database) is excluded.
\end{itemize}

The full baseline selection expression is any of the examples shown
above or a semi-colon-separated list of baseline specifications.  E.g.

\begin{itemize}
\item baseline={\tt 1$\sim$3\& ; 4$\sim$5\&10$\sim$15 ; VLA:N* \&
  VLA:E*}
\end{itemize}
with each elements of the semi-colon separated list being interpreted
as explained above.


\subsection{Integers-as-names VLA naming convention}
\label{VLACONVENTION}
Antenna naming convention for VLA is such that the antenna names are
actually valid integers converted to strings.  While we feel that this
is indeed a bad idea and it will be best to translate the VLA antenna
names to something like VLA1, VLA2 in the CASA VLA filler (or
something that does reflect that its a name and not get confused with
integer indexes), for now, to accommodate the VLA tradition, the
following logic is used:

\begin{description}
\item[] Just for antenna selection, a user supplied integer (or
  integer list) is converted to a string and matched against the
  antenna name.  If that fails, the normal logic of using an integer
  as an integer and matching it with antenna index is done.
\end{description}
Hence if the antenna with ID 17 is named "21", the string
\begin{verbatim}
"21",VLA22
\end{verbatim}
will expand into an antenna ID list of 17,22 (assuming that the
antenna named VLA22 has ID 22).

If we conclude that this style of antenna selection is indeed the way
we wish to go, users should be aware that the antenna selection will
behave differently for telescopes other than VLA.  Assuming that
antenna with names "21","17", and "11" have IDs 1,2,3 for VLA, a
selection string "21,17,11" will select antenna with IDs 1,2,3.  For
other instruments where this is not the naming convention, the same
selection string ("21,17,11") will select antennas with ID 21, 17, and
11.

%% \subsubsection{Note}

%% \begin{enumerate}
%% \item   Selection on polarization is not implemented.
%% \end{enumerate}

\section{Field Selection}
\label{FIELDEXPR}
\subsection{Syntax}

Field specifications can be literal field names, regular expressions
or patterns.  Leading and trailing blanks are stripped from the user
supplied field specifications as well as from the entries of the NAME
and field codes before being used for matching.  

Fields for which the entry in the NAME column of the the FIELD
sub-table match the literal field name/regular expression/pattern are
selected.  If a field name/regular expression/pattern fails to match
any field name, the given name/regular expression/pattern are matched
against the field code.  If still no field is selected, an exception
of type MSSelectionFieldParseError is thrown.

Field specifications can also be give by their integer IDs.  IDs can
be a single ID or a range of IDs (N0$\sim$N1).  Field ID selection can
also be done using a boolean expression.  For a field specification of
the form "$>$ID", all field IDs greater than ID are selected.
Similarly for "$<$ID" all field IDs smaller than ID are selected.

The field selection expression is a comma-separated list of field
specifications.  E.g.

\begin{itemize}
\item field={\tt 1,2,3,4} selects field IDs 1,2,3 and 4
\item field={\tt 1$\sim$4} same as above
\item field={\tt 1$\sim$4, VIRGO A , 3C*} selects field IDs 1,2,3,4
  field named "VIRGO A" and all fields with names starting with "3C".
\end{itemize}

\section{UV Distance Selection}

\subsection{Syntax}
\label{SPWEXPR}

A uv-distance specification is given as a physical quantity (number
with units in the format N[UNIT] where UNIT is optional).  This is
referred to as UVDIST in the description below.  Units are optional
with the default unit being meter.  Units can be specified as "m"/"M"
(for Mega) or "k"/"K" (for Kilo) followed by "m"/"M" (for meter) or
"lambda"/"LAMBDA" (for wavelength).  User supplied values are
converted to internal Measurement Set units using the spectral window
sensitive reference frequency.

If only a single UVDIST is specified, all rows that exactly match the
given UVDIST are selected.  When UVDIST is given as a range in the
format N0$\sim$N1[UNIT] (where N0 and N1 are valid numbers), all rows
corresponding to the uv-distance between N0 and N1 (N0 and N1
included) are selected.

Rows can also be selected via boolean expressions.  When specified in
the format "$>$UVDIST", all rows with uv-distance greater than the
given uv-distance (converted to the appropriate units) are selected.
When specified in the format "$<$UVDIST", all rows with uv-distance
less than the given uv-distance (converted to the appropriate units)
are selected.

To selected rows with uv-distance within an equal range on either side
of a given value, UVDIST can be specified as a percentage of the given
value in the format N\%.  All rows with uv-distance between +/-N
percent of the given uv-distance in appropriate units are selected.

The full uv-distance selection expression is a comma-separated list of
any of the above mentioned uv-distance specifications.  E.g.

\begin{itemize}
\item uvdist={\tt 100Klambda} selects all baselines for which
  $\sqrt{u^2+v^2}$ is equal to 100 K$\lambda$.
\item uvdist={\tt 100Km} selects all baselines for which
  $\sqrt{u^2+v^2}$ is equal to 100 Km.
\item uvdist={\tt 100$\sim$200Klambda} selects all baselines for which
  $\sqrt{u^2+v^2}$ is in the range [100, 200] K$\lambda$.
\item uvdist={\tt $>$100Klambda} selects all baselines for which
  $\sqrt{u^2 + v^2}$ is greater than 100 K$\lambda$.
\item uvdist={\tt $<$100Klambda} selects all baselines for which
  $\sqrt{u^2 + v^2}$ is less than 100 K$\lambda$.
\end{itemize}

\section{Frequency Selection}

Frequency selection expression consists of two specifications
separated by colon (':') in the form:

\begin{verbatim}
      SPWSPEC[:CHANSPEC]
\end{verbatim}
where SPW is the spectral window specification and CHANSPEC is the
optional frequency specification for selection within the selected
spectral windows.  When channel specification is omitted, all channels
of the selected SPW are selected.

SPWSPEC and CHANSPEC allow use of semi-colon separated lists.  As a
result, list of SPWSPEC can be given in two ways: (1) a semi-colon
separated list, (2) coma separated list.  This allows simple
selections to remain simple and more complex selections consistent
with the syntax for CHANSPEC list.

\subsection{Spectral Window Specification Syntax}

Spectral windows (SPW) specification can be a single ID or a list of
spectral window integer IDs, a spectral window name (as a literal
string (for exact match)/regular expression/pattern) or a reference
frequency value (value with a unit).  A single frequency specification
is used for exact match with the REF\_FREQUENCY column of the
SPECTRAL\_WINDOW sub-table.  A range of frequencies are used to select
all SPWs which are within the given range.  The allowed units are Hz,
KHz, MHz, GHz or THz.

SPWs can also be selected via a boolean expression for integer IDs.

\begin{itemize}
\item "$>$ID" will select all SPWs with ID greater than the specified
  value.
\item "$<$ID" will select all SPWs with ID lesser than the specified
  value.
\item "$>$FREQ" will select all SPWs, the reference frequencies of
  which are greater than the given frequency converted to Hz.
\item "$<$FREQ" will select all SPWs, the reference frequencies of
  which are greater than the given frequency converted to Hz.
\end{itemize}
E.g.
\begin{itemize}
\item spw={\tt 1,2,3} selects spectral window IDs 1,2 and 3
\item spw={\tt 1;2;3} same as above.  This style can be used along
  with CHANSPEC
\item spw={\tt 1$\sim$3} same as above
\item spw={\tt 327MHz} selects spectral window with a reference
  frequency equal to 327.0 MHz
\item spw={\tt 327$\sim$610MHz} selects all spectral windows with
  reference frequencies in the range [327.0, 610.0] MHz.
\item spw={\tt 1421MHz, 1422MHz, 1423MHz} selects SPWs with reference
  frequency 1421.0, 1422.0 and 1423.0 MHz.
\item spw={\tt 1421MHz; 1422MHz; 1423MHz} same as above.  This style
  can be used along with CHANSPEC.
\item spw={\tt $>$327MHz} selects all spectral windows with reference
  frequency greater than 327.0 MHz
\item spw={\tt $<$327MHz} selects all spectral windows with reference
  frequency less than 327.0 MHz
\end{itemize}

\subsection{Channel Selection Syntax}

Channel specification\footnote{\it MSSelection module is currently
  used to only parse the channel selection expression to produce the
  START,STOP,STEP tuples.  No channel based selection is actually
  applied to the data.  The list of tuples per SPW is passed to the
  application program layer and the interpretation of the tuples for
  actual selection depends on the application programmer.} (referred
to as CHANSPEC in the following description) is a START,STOP,STEP
tuple corresponding to the first frequency channel, the last frequency
channel and the step size to increment from the first to the last
channel.  The START and STOP part of the tuple can be range
specification for the range [START, STOP] followed by an optional STEP
size.

START and STOP part of the tuple can be specified as a single integer
or physical quantity or as a range of integers or physical quantities.
A single integer is treated as a channel index and the tuple
corresponds to [ID,ID,1].  A single physical quantity is matched with
the exact frequency value of the channels and tuple of matched channel
index is constructed as [ID,ID,1].  A range of integers given as
N0$\sim$N1 is used to construct a tuple [N0,N1,1].  Similarly for a
range of physical quantities.

If a START,STOP part of the tuple specification is followed by
"\char94 STEP", the STEP is used as the third value of the tuple.
STEP specification is a single integer or physical quantity.
E.g. 0$\sim$10\char94 2 is converted to a START,STOP,STEP tuple
[0,10,2].

A channel selection expression is a semi-colon separated list of
channel specifications.  E.g.

\begin{itemize}
\item chan={\tt 1;2;3} selects channels 1,2 and 3.
\item chan={\tt 1$\sim$3} selects channels 1,2 and 3.
\item chan={\tt 0$\sim$10\char94 2} selects channels in the range
  [0,10] with a step size of 2
\item chan={\tt 1421MHz} selects a frequency channel corresponding to
  the frequency 1421.0 MHz
\item chan={\tt 1421$\sim$1500MHz} selects all channels in the range
  [1412.0, 1500.0] MHz
\item chan={\tt 1421$\sim$1500MHz\char94 10KHz} selects all channels
  in the range [1421.0, 1500.0] MHz in steps of 10 KHz.
\item chan={\tt 1421$\sim$1500MHz\char94 10KHz ; 0$\sim$10\char94 2 ;
  20 ; 30; 40} selects all channels in the range [1421.0, 1500.0] MHz
  in steps of 10KHz, all channels with indexes in the range [0,10] in
  steps of 2 channels and channels 10, 20 and 30.
\end{itemize}

\subsection{ Frequency Selection Syntax}

The specifications for SPW and channels can be combined to form a
fully qualified frequency selection expression in the form
SPWSPEC[:CHANSPEC] (square brackets indicate that :CHANSPEC is
optional).  A frequency selection expression is a comma-separated list
of SPWSPEC[:CHANSPEC] specifications.  Channel selections apply to all
SPWs selected by the SPWSPEC on the left of ':'.  E.g.

\begin{itemize}
\item freq={\tt LBAND:1421$\sim$1500MHz\char94 10KHz ,
  327MHz:300$\sim$400MHz, 0$\sim$4:0$\sim$10\char94 2 , 5:20;30;40}

       selects 

\begin{itemize}
	\item all channels corresponding to channels in the range
          [1421.0, 1500.0] MHz for the SPW named "LBAND", and
	\item all channels corresponding to the range [300.0,
          400.0]MHz for the SPW with a reference frequency of 327.0
          MHz, and
	\item Channels in the range [0,10] in steps of 2 for all SPWs
          with IDs in the range [0,4], and
	\item Channels 20, 30 and 40 for SPW 5
\end{itemize}          

\item freq={\tt 1421Mhz;1422Mhz;1423Mhz :
  0;1;2;10$\sim$20;30$\sim$100$\sim$10 ,0$\sim$3:10$\sim$30}

	 selects

\begin{itemize}
    \item Channels 0, 1, 2 for SPWs with reference frequency of
      1421.0, 1422.0 and 1423.0 MHz.
    \item Channels 10 to 20 in step of 1 channel for SPWs with
      reference frequency of 1421.0, 1422.0 and 1423.0 MHz.
    \item Channels 30 to 100 in steps of 10 channel for SPWs with
      reference frequency of 1421.0, 1422.0 and 1423.0 MHz.
    \item Channels 10 to 30 in step of 1 channel for SPW IDs 0 to 3 in
      step of 1.
\end{itemize}          

\end{itemize}          
      
\subsubsection{Notes}

\begin{enumerate}
\item For channel specifications of the type {\tt
  N1$\sim$N2:c0;c1;c2;c3MHz} the list of channel selection is applied
  to all SPWs in the range [N0, N1].  c3 is converted from physical
  units to channel index by using the channel width from SPW N1. Is it
  better to use the min. chan. among the selected SPWs?

\item If channel range is out of bounds, it will be brought within
  bounds per SPW.  If the lower limit of a range is greater than the
  available outer limit, exception is generated.  If the lower limit
  is less than zero, it is set to zero.  If upper limit is greater
  than the available outer limit, it is set to the available outer
  limit.

  If a single channel specification is greater than the available
  outer limit, an exception is thrown.  If it is less than zero, it is
  set to zero.

\item For ranges of physical values, it is assumed that the spectral
  window sub-table's CHAN\_FREQ column has ordered list of channel
  frequencies.
\end{enumerate}

\section{Polarization Selection}

The structure of the Measurement Set allows independent set up for the
frequency and polarization description of the data\footnote{The
  combined main-table descriptor for spectral windows and polarization
  is the Data Description ID (DDID).  DDID represents a two-level
  indirection based on the the Spectral Window and Polarization
  sub-tables (which are the real astro-physically relevant parameters
  of the database).}.  E.g., it is valid to have data at 1420MHz, with
some fraction of the data recorded with only parallel hand
polarizations (e.g. "RR" and "LL") and some fraction of the data
recorded in full polarization mode (e.g. "RR", "LL", "RL", and "LR").
Note however that a polarization set up describes a spectral window
and not the individual frequency channels in a spectral window.

Consequently, polarization selection expressions may need to be
qualified with the spectral window and polarization ID specification
as well.  Therefore, current the polarization selection expressions
are of the type {\tt [SPW:]POL}\footnote{A full specification of the
  type {\tt [[POLID:][SPWID:]POL} or {\tt [DDID::]POL} will be
    implemented in future.}.  The {\tt SPW} part of such expressions
  follow the syntax of the Spectral Window Selection expression (see
  Section~\ref{SPWEXPR}) -- except that the channel specifications are
  not allowed here.

As with other expressions, the polarization selection expression also
consists of comma separated list of full specifications.  The
separator for lists for the individual parts of the specification
(i.e. {\tt SPW}, {\tt POL}, etc.) is semi-colon. However note that if
the optional qualifiers are omitted (i.e., {\tt SPW} etc.), either of
the separaters can be used (comma or semi-colon).  Thus {\tt "RR;LL"}
is equivalent to {\tt "RR,LL"}.

The {\tt POL} specification is a semi-colon separated list of
polarization products (i.e., it is a baseline based selection).
E.g. {\tt POL} can be {\tt "RR"} or {\tt "LL"} or {\tt "RR;LR"} or
{\tt "RR;LL;LR;RL"}, etc.  Without the qualifiers, comma can also be
used as a separater.  Polarization specifications in the list can be
in any order.  A number of {\tt [SPW:]POL} specifications can be given
as a comma separated list.  E.g.

\begin{itemize}
\item "poln=RR" will select data corresponding to RR polarization
  product only.
\item "poln=RR,LL,LR,RL" will select all polarization products.
\item "poln=RR ; LL ; LR ; RL" same as the previous expression.
\item "poln=0:RR;LL , 1:LR;RL'' will select RR and LL from spectral
  window 0 and LR and RL from spectral window 1.
\end{itemize}


\section{Scan/Sub-array Selection}

Scan and sub-arrays selections are purely integer ID based selections.
The syntax for the specification of both these is therefore identical.

\subsection{Syntax}

Scan and Sub-array selection specification is a single integer (INT) or
a range of integers(N0$\sim$N1).  Scans and sub-arrays can also be selected
via boolean expressions of the type "$>$INT", "$>$=INT", "$<$INT" or
"$<$=INT"\footnote{{\it Programmers note:}
The getScanList() (getSubArrayList() for sub-arrays) method will
return the list generated from INT,INT,... or INT$\sim$INT or "$<$INT"
specification.  For "$>$INT" specification, the returned list will be
number from INT part of "$>$INT" upto the maxScans (maxArrays for
sub-arrays) set via MSSelection::setMaxScan()
(MSSelection::setMaxArray() for sub-arrays).  The default value of
maxScans/maxArrays is {\tt std::standard\_limits$<$int$>$::max()}
(i.e. the maximum value an integer can take on a machine).  It is done
this way since there is no efficient way of generating a list of
SCAN/ARRAY IDs present in the data and "$>$INT" is an unbounded list
of integers.  The list of scans IDs in the data can be {\bf probably}
generated using the MSRange class - but I think it can be quite
expensive.  So if it is necessary to know the precise list of scans
selected using the "$>$INT" specification, the application programs
will have to use MSRange class to get the range in the data.  An
intersection of the list from MSRange and the list from
MSSelection.getScanList() will be the actual selected scans
(intersection of two CASA vectors can be done using the
set\_intersection() global method in MSSelectionTools.h).
}.

Full expression is a comma-separated list of any of the above index
specifications.  E.g.

\begin{itemize}
\item scan={\tt 0,1,2,3}  selects scan numbers 0, 1, 2 and 3
\item scan={\tt 0$\sim$3}      selects scans in the range [0,3]
\item scan={\tt 0$\sim$3,4,5}  selects scans in the range [0,3] and scans 4 and 5 
\item scan={\tt $>$5}       selects all scans greater than 5
\item scan={\tt $<$5}       selects all scans less than 5
\end{itemize}

\newpage
\appendix{}
\section{Appendix: General Error Handling}

The MSSelection sub-system reports errors via the C++ exception
mechanism.  The objects thrown have the following inheritance
hierarchy:

\begin{center}
\begin{verbatim}
                          AipsError
                              o
                              |
                              |
                       MSSelectionError
                              o
                              |
                              |
     MSSelection{Time,Spw,UvDist,Antenna,Scan,Subarray}Error
                              o
                              |
                              |
   MSSelection{Time,Spw,UvDist,Antenna,Scan,Subarray}ParseError
\end{verbatim}
\end{center}

All parsing errors are reported by throwing the {\tt
  MSSelection\{Time, Spw, Field, UvDist, Antenna, Scan,
  Subarray\}ParseError} exception.  All other forms of errors
(e.g. illegal range specification N0$\sim$N1 where N0 $>$ N1) are
reported by throwing an exception of type {\tt MSSelection\{Time, Spw,
  Field, UvDist, Antenna, Scan, Subarray\}Error}.

Hence, to catch all errors thrown from the MSSelection sub-system,
catch the MSSelectionError object.  For more specific exception
handling, catch the more qualified MSSelection*Error objects.  For
catching only parsing errors, catch the MSSelection*ParseError object.
As is obvious, any un-caught exception from the MSSelection sub-system
will be caught in the AipsError catch block.

The exceptional error message consists of a human understandable
one-line description of the error, the string which caused the error
and the possible location in the string of the erroneous
character.  E.g.

 Spw Expression: No match found for "LBAN" (near char. 4 in string "LBAN")

\newpage
\section{Appendix: Examples}

\begin{table}[h!]
\caption{Summary of the MS used}
\begin{center}
\begin{tabular}{|c|c|c|c|l|c|}
\hline
FIELDID & SPWID &  NChan & Pol & NRows   & Source Name\\
\hline
   0    &  0    &   127  &  RR &  10260  &  0530+135  \\
   1    &  0    &   127  &  RR &  779139 &  05582+16320  \\
   2    &  0    &   127  &  RR &  296190 &  05309+13319  \\
   3    &  0    &   127  &  RR &  58266  &  0319+415      \\
   4    &  0    &   127  &  RR &  32994  &  1331+305      \\
   5    &  1,2  &    1   &  RR,RL,LL,RR  &  23166&  KTIP  \\
\hline
\end{tabular}
\end{center}
\end{table}

\subsection{Example 1}
\begin{verbatim}
--------------------------------------------------------------------
Select field IDs 0,1,2 and field Named KTIP
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas named "1" to "10"
       Spw:  0  Channels: 10 to 30 in steps of 1
--------------------------------------------------------------------
sbhatnag@atlas>mssplit
mssplit>inp
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = 0~2,KTIP
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 0:10~30
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [0, 1, 2, 5]
SPW  = [0]
Chan = [10, 30, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 99819
\end{verbatim}

\subsection{Example 2}

\begin{verbatim}
--------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas named "1" to "10"
       Spw:  All available channels for spw 1 and 2
--------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1,2
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [5]
SPW  = [1, 2]
Chan = SPW 1 : Channels [0, 0, 1]
       SPW 2 : Channels [0, 0, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 2376
\end{verbatim}

\subsection{Example 3}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas *named* "1" to "10"
       Spw:  SPW ID 0

       No data should be selected
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 0
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [5]
SPW  = [0]
Chan = SPW 0 : Channel [0, 126, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 0
\end{verbatim}

\subsection{Example 4}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas *named* "1" to "10"
       Spw:  SPW ID 1
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channels [0, 0, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 1188
\end{verbatim}


\subsection{Example 5}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Between antennas "1" to "3" and "4" to "6"
       Spw:  SPW ID 1
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1,2,3&4,5,6
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17]
Ant2 = [4, 24, 3]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channel [0, 0, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 198
\end{verbatim}

\subsection{Example 6}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Error in antenna specification
       Spw:  All spectral windows
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~3 & $~6
uvdist     =
mssplit>go
###AipsError: Antenna Expression: Parse error at or near '$' (near
char. 7 in string "1~3 & $~6")
\end{verbatim}

\subsection{Example 7}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Use antenna ranges
       Spw:  1
       UVRange: [0,5000] K-Lambda
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~3 & 4~6
scan       =
array      =
uvdist     = 0~5klambda
mssplit>go
Ant1 = [21, 10, 17]
Ant2 = [4, 24, 3]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channel [0, 0, 1]
Scan = []
Array = []
UVRange = [0, 5000] lambda
Number selected rows: 33
\end{verbatim}

\subsection{Example 8}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Baselines between antennas "1" to "3" and "4" to "6"
                  and baseline "10"-"11"
       Spw:  1
       UVRange: [0, 5000] K-Lambda
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~3 & 4~6 ; 10&11
scan       =
array      =
uvdist     = 0~5klambda
mssplit>go
Ant1 = [21, 10, 17, 6]
Ant2 = [4, 24, 3, 1]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channel [0, 0, 1]
Scan = []
Array = []
UVRange = [0, 5000] lambda
Number selected rows: 33
\end{verbatim}

\subsection{Example 9}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: Error in range operator
       Baselines: Baselines between antennas "1" to "3" and "4" to "6"
       Spw:  All spectral windows
       UVRange: [0, 5000] K-Lambda
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = /home/rohir3/sanjay/CASATests/G192.ms/
outms      = tt.ms
field      = K*
time       = 25/22:40:0 - 26/03:30:0
spw        = 1
baseline   = 1~3 & 4~6 ; 10&11
scan       =
array      =
uvdist     = 0~5klambda
mssplit>go
First selected timestamp = 26-Apr-2003/03:20:45.0
###MSSelectionError: MSSelection time error: Parse error at or near
token '-' (near char. 12 in string "25/22:40:0 - 26/03:30:0")
(Did you know we use "~" as the range operator (for a good reason)?)
\end{verbatim}

\newpage
\section{Appendix: Formal Grammar Specifications}

{\tt TEN} in the following refers to the TableExprNode object of the
{\tt Tables} module of CASA.

\subsection{Baseline Selection Expression}

\begin{verbatim}

token IDENTIFIER of type String
token COMMA

token LPAREN
token RPAREN
token WHITE

token INT      of type String
token QSTRING  of type String
token REGEX    of type String

token COLON
token SEMICOLON

type TEN antennastatement
type TEN indexcombexpr
type Vector<int> indexlist
type Vector<int> antidrange
type Vector<int> antidlist
type Vector<int> antid

antennastatement: indexcombexpr 
                | LPAREN indexcombexpr RPAREN

indexcombexpr: indexcombexpr SEMICOLON indexcombexpr
             | indexlist AMPERSAND indexlist 
             | indexlist AMPERSAND 
             | indexlist 

antid: IDENTIFIER 
     | QSTRING 
     | REGEX

antidrange: INT 
          | INT TILDA INT 
 
antidlist: antid 
         | antidrange
 
indexlist: antidlist
         | indexlist COMMA antidlist
         | LPAREN indexlist RPAREN 
\end{verbatim}


\subsection{Frequency Selection Expression}

\begin{verbatim}

token UNIT       of type String
token INT        of type String
token FNUMBER    of type String
token QSTRING    of type String
token REGEX      of type String
token IDENTIFIER of type String

type TEN SpwStatement
type TEN FullSpec
type TEN FullExpr
type Float[2] OneFreq
type Float[2] FreqRange
type Float[2] Physical
type Float[4] IndexRange
type Float[4] PhyRange
type Vector<int>    Spw
type Float[2] FListElements
type Vector<Float>   FreqList
type Float PhyVal


SpwStatement: FullExpr | LPAREN FullExpr RPAREN

PhyVal: FNUMBER

Physical: PhyVal UNIT

PhyRange: Physical TILDA Physical
        | PhyVal TILDA PhyVal UNIT
        | PhyRange CARET Physical 

IndexRange: PhyVal TILDA PhyVal
          | IndexRange CARET PhyVal

FreqRange: IndexRange
         | PhyRange

OneFreq:  PhyVal
        | Physical

FListElements: FreqRange
             | OneFreq

FreqList: FListElements
        | FreqList SEMICOLON FListElements

Spw: IDENTIFIER
   | QSTRING
   | REGEX
   | OneFreq
   | GT OneFreq
   | LT OneFreq
   | TILDA OneFreq
   | FreqRange
   
FullSpec: Spw 
        | Spw COLON FreqList

FullExpr: FullSpec
        | FullExpr COMMA FullSpec

\end{verbatim}


\subsection{Field Selection Expression}

\begin{verbatim}
token SQUOTE
token IDENTIFIER  of type String
token COMMA

token LPAREN
token RPAREN
token WHITE

token INT      of type String
token QSTRING  of type String
token REGEX    of type String

token COLON
token SEMICOLON

type TEN fieldstatement
type TEN indexcombexpr
type Vector<int> indexlist
type Vector<int> fieldidrange
type Vector<int> fieldidlist
type Vector<int> fieldid
type Vector<int> fieldidbounds

fieldstatement: indexcombexpr 
              | LPAREN indexcombexpr RPAREN

indexcombexpr: indexlist 

fieldid: IDENTIFIER   
       | QSTRING 
       | REGEX

fieldidrange: INT                     
            | INT TILDA INT           

fieldidbounds: LT INT                  
             | GT INT                  
             | GT INT AMPERSAND LT INT 

fieldidlist: fieldid                   
           | fieldidrange              
           | fieldidbounds             

indexlist : fieldidlist
          | indexlist COMMA fieldidlist  
          | LPAREN indexlist RPAREN
\end{verbatim}


\subsection{Scan/Sub-Array Selection Expression}

\begin{verbatim}
token IDENTIFIER  of type String
token COMMA

token LPAREN
token RPAREN
token WHITE

token INT      of type String
token QSTRING  of type String
token REGEX    of type String

token COLON
token SEMICOLON

type TEN scanstatement
type TEN indexcombexpr
type TEN scanidrange
type TEN scanidbounds

scanstatement: indexcombexpr 
             | LPAREN indexcombexpr RPAREN

indexcombexpr: scanidrange
             | scanidbounds
             | scanidrange COMMA indexcombexpr
             | scanidbounds COMMA indexcombexpr

scanidbounds: LT INT
            | GT INT
            | LE INT
            | GE INT
            | GE INT AMPERSAND LE INT
            | GT INT AMPERSAND LT INT

scanidrange: INT
           | INT TILDA INT

\end{verbatim}


\subsection{Time Selection Expression}

\begin{verbatim}
token NUMBER  of type Integer
token FNUMBER of type Double

token TILDA
token LT
token GT
token COLON
token COMMA
token SLASH
token DOT
token STAR

type TEN timestatement
type TEN timeexpr
type TEN singletimeexpr
type TEN rangetimeexpr
type TEN upboundtimeexpr
type TEN lowboundtimeexpr
type Struct TimeFields yeartimeexpr
type Double FLOAT
type Vector<int> WNUMBER

timestatement: timeexpr 

timeexpr: singletimeexpr
        | rangetimeexpr
        | lowboundtimeexpr
        | upboundtimeexpr
        | timeexpr COMMA timeexpr 

WNUMBER: STAR 
       | NUMBER

FLOAT: WNUMBER 
     | FNUMBER {$$ = $1;}

singletimeexpr: yeartimeexpr 

rangetimeexpr: yeartimeexpr TILDA yeartimeexpr 
             | yeartimeexpr PLUS yeartimeexpr

lowboundtimeexpr: GT yeartimeexpr 

upboundtimeexpr: LT yeartimeexpr 

yeartimeexpr: WNUMBER SLASH WNUMBER SLASH WNUMBER SLASH WNUMBER
                COLON WNUMBER COLON FLOAT
            | WNUMBER SLASH WNUMBER SLASH WNUMBER SLASH WNUMBER
                COLON WNUMBER 
            | WNUMBER SLASH WNUMBER SLASH WNUMBER SLASH WNUMBER 
            | WNUMBER SLASH WNUMBER SLASH WNUMBER 
            | WNUMBER SLASH WNUMBER SLASH WNUMBER 
                COLON WNUMBER COLON FLOAT
            | WNUMBER COLON WNUMBER COLON FLOAT
            | WNUMBER COLON FLOAT
            | FLOAT
            | WNUMBER SLASH WNUMBER COLON WNUMBER COLON FLOAT 
            | WNUMBER SLASH WNUMBER COLON WNUMBER 
            | WNUMBER SLASH WNUMBER 

\end{verbatim}

\subsection{UV-distance Selection Expression}

\begin{verbatim}
token UNIT     of type String
token FNUMBER of type Double
token COLON  
token COMMA
token PERCENT

type Double fnumwithunits
type TEN uvwdiststatement
type TEN uvwdistexprlist
type TEN uvwdistexpr

uvwdiststatement:uvwdistexprlist

uvwdistexprlist: uvwdistexpr 
               | uvwdistexprlist COMMA uvwdistexpr 

fnumwithunits: FNUMBER
             | FNUMBER UNIT

uvwdistexpr: fnumwithunits
           | FNUMBER TILDA fnumwithunits
           | LT fnumwithunits
           | GT fnumwithunits
           | fnumwithunits COLON FNUMBER PERCENT 

\end{verbatim}
\end{document}
