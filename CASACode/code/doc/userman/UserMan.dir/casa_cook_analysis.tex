%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% STM 2007-04-13  split from previous version
% STM 2007-08-01  add immoments and regridimage
% STM 2007-10-10  beta release (spell-checked)
% GvM 2008-03-12  add imcontsub
% STM 2008-03-17  immath, imstat, update imhead
% STM 2008-05-14  start patch 2.0, return vars, imfit
% STM 2008-06-03  more edits
% STM 2008-09-30  Patch 3 editing start, imval
% STM 2008-11-17  Patch 3 imregrid
% STM 2009-05-20  Patch 4 imsmooth, etc.
% STM 2009-12-16  Release 0

\chapter{Image Analysis}
\label{chapter:analysis}

\begin{wrapfigure}{r}{2.5in}
  \begin{boxedminipage}{2.5in}
     \centerline{\bf Inside the Toolkit:}
     Image analysis is handled in the {\tt ia} tool.
     Many options exist there, including region statistics and
     image math. See \S~\ref{section:analysis.toolkit} below
     for more information.
  \end{boxedminipage}
\end{wrapfigure}

Once data has been calibrated (and imaged in the case of synthesis
data), the resulting image or image cube must be displayed or 
analyzed in order to extract quantitative information, such as
statistics or moment images.  In addition, there need to be facilities for
the coordinate conversion of images for direct comparison.
We have assembled a skeleton of image analysis tasks for
this release.  Many more are still under development.

The image analysis tasks are:
\begin{itemize}
   \item {\tt imhead} --- summarize and manipulate the ``header'' 
         information in a CASA image 
         (\S~\ref{section:analysis.imhead})
   \item {\tt imcontsub} --- perform continuum subtraction on a
         spectral-line image cube 
         (\S~\ref{section:analysis.imcontsub})
   \item {\tt imfit} --- image plane Gaussian component fitting
         (\S~\ref{section:analysis.imfit})
   \item {\tt immath} --- perform mathematical operations on or
         between images
         (\S~\ref{section:analysis.immath})
   \item {\tt immoments} --- compute the moments of an image cube
         (\S~\ref{section:analysis.moments})
   \item {\tt imstat} --- calculate statistics on an image or part
         of an image
         (\S~\ref{section:analysis.imstat})
   \item {\tt imval} --- extract the data and mask values from a
         pixel or region of an image
         (\S~\ref{section:analysis.imval})
   \item {\tt imregrid} --- regrid an image onto the coordinate
         system of another image 
         (\S~\ref{section:analysis.regrid})
   \item {\tt imsmooth} --- smooth images in the spectral and angular directions
         (\S~\ref{section:analysis.imsmooth})
   \item {\tt importfits} --- import a FITS image into a CASA  
         {\it image} format table 
         (\S~\ref{section:analysis.fits.import})
   \item {\tt exportfits} --- write out an image in FITS format
         (\S~\ref{section:analysis.fits.export})
\end{itemize}

There are other tasks which are useful during image analysis.  These
include:
\begin{itemize}
   \item {\tt viewer} --- there are useful region statistics and
         image cube slice and profile capabilities in the viewer 
         (\S~\ref{chapter:display})
\end{itemize}

We also give some examples of using the CASA Toolkit to aid in
image analysis (\S~\ref{section:analysis.toolkit}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Common Image Analysis Task Parameters}
\label{section:analysis.pars}

We now describe some sets of parameters are are common to the image
analysis.  These should behave the same way in any of the tasks
described in this section that they are found in.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Region Selection ({\tt box})}
\label{section:analysis.pars.box}

Area selection in the image analysis tasks is controlled by
the {\tt box} parameter or through the {\tt regions}
parameter (\S~\ref{section:analysis.pars.regions}).

The {\tt box} parameter selects rectangular areas:
\small
\begin{verbatim}
box        =      ''   #  Select one or more box regions

#          string containing blcx,blcy,trcx,trcy

#          A box selection in the directional portion of an image.
#          The directional portion of an image are the axes for right
#          ascension and declination, for example.  Boxes are specified
#          by there bottom-left corner (blc) and top-right corner (trc)
#          as follows: blcx, blcy, trcx, trcy;
#          ONLY pixel values acceptable at this time.
#          Default: none (all);
#          Example: box='0,0,50,50'
#          Example: box='[10,20,30,40];[100,100,150,150]'

\end{verbatim}
\normalsize

To get help on {\tt box}, see the in-line help
\small
\begin{verbatim}
     help(par.box)
\end{verbatim}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Plane Selection ({\tt chans}, {\tt stokes})}
\label{section:analysis.pars.planes}

The channel, frequency, or velocity plane(s) of the image is chosen
using the {\tt chans} parameter:
\small
\begin{verbatim}
chans      =      ''   #  Select the channel(spectral) range

#          string containing channel range

#          immath, imstat, and imcontsub - takes a string listing
#          of channel numbers, velocity, and/or frequency
#          numbers, much like the spw paramter
#          Only channel numbers acceptable at this time.
#          Default: none (all);  
#          Example: chans='3~20'    
#                   chans="0,3,4,8"
#                   chans="3~20,50,51"
\end{verbatim}
\normalsize

The polarization plane(s) of the image is chosen with the {\tt stokes}
parameter:
\small
\begin{verbatim}
stokes     =      ''   #  Stokes params to image (I,IV,IQU,IQUV)

#          string containing Stokes selections

#          Stokes parameters to image, may or may not be separated
#          by commas but best if you use commas.
#          Default: none (all); Example: stokes='IQUV';  
#          Example:stokes='I,Q'
#          Options: 'I','Q','U','V',
#                   'RR','RL','LR','LL',
#                   'XX','YX','XY','YY',...
\end{verbatim}
\normalsize

To get help on these parameters, see the in-line help
\small
\begin{verbatim}
     help(par.chans)
     help(par.stokes)
\end{verbatim}
\normalsize

Sometimes, as in the {\tt immoments} task, the channel/plane 
selection is generalized to work on more than one axis type.
In this case, the {\tt planes} parameter is used.  This behaves
like {\tt chans} in syntax.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Lattice Expressions ({\tt expr})}
\label{section:analysis.pars.lattice}

Lattice expressions are strings that describe operations on a
set of input images to form an output image.  These strings
use the {\em Lattice Expression Language} (LEL).  LEL syntax
is described in detail in AIPS++ Note 223 
\begin{quote}
   \url{http://aips2.nrao.edu/docs/notes/223/223.html}
\end{quote}
{\bf ALERT:} This document was written in the context of
glish-based AIPS++ and is not yet updated to CASA syntax 
(see below).

The {\tt expr} string contains the LEL expression:
\small
\begin{verbatim}
expr       =      ''   #  Mathematical expression using images

#          string containing LEL expression

#          A mathematical expression, with image file names.
#          image file names must be enclosed in double quotes (")
#          Default: none 
#          Example: expr='min("image2.im")+(2*max("image1.im"))'
#
#    Available functions in the expr and mask paramters:
#    pi(), e(), sin(), sinh(), asinh(), cos(), cosh(), tan(), tanh(),
#    atan(), exp(), log(), log10(), pow(), sqrt(), complex(), conj()
#    real(), imag(), abs(), arg(), phase(), aplitude(), min(), max()
#    round(), isgn(), floor(), ceil(), rebin(), spectralindex(), pa(), 
#    iif(), indexin(), replace(), ...
\end{verbatim}
\normalsize

For examples using LEL {\tt expr}, see 
\S~\ref{section:analysis.immath.examples} below.  Note that in
{\tt immath}, shortcut names have been given to the images provided
by the user in {\tt imagename} that can be used in the LEL expression,
for the above example:
\small
\begin{verbatim}
  imagename=['image2.im','image1.im']
  expr='min(IM0)+(2*max(IM1))'
\end{verbatim}
\normalsize

{\bf ALERT:} As of Patch 2, LEL expressions use 0-based indices.
Also, the functions must be lowercase (in almost all cases we know
about).
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Masks ({\tt mask})}
\label{section:analysis.pars.mask}

The {\tt mask} string contains a LEL expression 
(see \S~\ref{section:analysis.pars.lattice} above).  This string
can be an on-the-fly (OTF) mask expression or refer to an 
image pixel mask.
\small
\begin{verbatim}
mask       =      ''   #  Mask to be applied to the images

#          string containing LEL expression

#          Name of mask applied to each image in the calculation
#          Default '' means no mask;  
#          Example: mask='"ngc5921.clean.cleanbox.mask">0.5'
#                   mask='mask(ngc5921.clean.cleanbox.mask)'
\end{verbatim}
\normalsize

Note that the mask file supplied in the {\tt mask} parameter must have
the same shape, same number of axes and same axes length, as the
images supplied in the {\tt expr} parameter, with one exception. The mask
may be missing some of the axes --- if this is the case then the mask
will be expanded along these axes to become the same shape.

For examples using {\tt mask}, see \S~\ref{section:analysis.immath.masks} 
below.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Regions ({\tt region})}
\label{section:analysis.pars.regions}

The {\tt region} parameter points to an ImageRegion file.  An
ImageRegion file can be created with the CASA {\tt viewer}'s region
manager (\S~\ref{section:display.image.rgnmgr}).
Typically ImageRegion files will have the suffix {\tt '.rgn'}.  
If a region file is given then the {\tt box}, {\tt chans}, and
{\tt stokes} parameters will be ignored.

For example: 
\small
\begin{verbatim}
    region='myimage.im.rgn'
\end{verbatim}
\normalsize


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Image Header Manipulation ({\tt imhead})}
\label{section:analysis.imhead}

To summarize and change keywords and values in the ``header'' of
your image, use the {\tt imhead} task.  Its inputs are:
\small
\begin{verbatim}
#  imhead :: Lists, gets and puts image header parameters
imagename      =         ''   #   Name of input image file
mode           =  'summary'   #   Options: get, put, summary, list, stats
async          =      False      
\end{verbatim}
\normalsize

The {\tt mode} parameter controls the operation of {\tt imhead}.

Setting {\tt mode='summary'} will print out a summary of the image
properties and the header to the logger.

Setting {\tt mode='list'} prints out a list of the header keywords
and values to the terminal.

The {\tt mode='get'} allows the user to retrieve the current value 
for a specified keyword {\tt hdkey}:
\small
\begin{verbatim}
mode           =      'get'   #  imhead options: list, summary, get, put
   hdkey       =         ''   #  The FITS keyword
\end{verbatim}
\normalsize
Note that to catch this value, you need to assign it to a Python
variable.
See \S~\ref{section:intro.tasks.return} for more on return values.

The {\tt mode='put'} allows the user to replace the current value 
for a given keyword {\tt hditem} with that specified in {\tt hdvalue}.  
There are two sub-parameters that are opened by this option:
\small
\begin{verbatim}
mode           =      'put'   #  imhead options: list, summary, get, put
   hdkey       =         ''   #  The FITS keyword
   hdvalue     =         ''   #  Value of hdkey
   hdtype      =         ''   #  Data type of the header keyword.
   hdcomment   =         ''   #  Comment associated with the header keyword

\end{verbatim}
\normalsize
{\bf WARNING:} Be careful when using {\tt mode='put'}.  This task does
no checking on whether the values you specify (e.g. for the axes
types) are valid, and you can render your image invalid.  Make sure you
know what you are doing when using this option!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Examples for {\tt imhead}}
\label{section:analysis.imhead.examples}

The following uses the example images from NGC5921
(\S~\ref{section:scripts.ngc5921}).

We can print the summary to the logger:
\small
\begin{verbatim}
CASA <51>: imhead('ngc5921.demo.cleanimg.image',mode='summary')
\end{verbatim}
\normalsize
prints in the logger: 
\small
\begin{verbatim}
##### Begin Task: imhead             #####
  Image name       : ngc5921.demo.cleanimg.image
  Object name      : N5921_2
  Image type       : PagedImage
  Image quantity   : Intensity
  Pixel mask(s)    : None
  Region(s)        : None
  Image units      : Jy/beam
  Restoring Beam   : 52.3782 arcsec, 45.7319 arcsec, -165.572 deg
  
  Direction reference : J2000
  Spectral  reference : LSRK
  Velocity  type      : RADIO
  Rest frequency      : 1.42041e+09 Hz
  Pointing center     :  15:22:00.000000  +05.04.00.000000
  Telescope           : VLA
  Observer            : TEST
  Date observation    : 1995/04/13/00:00:00
  Telescope position: [-1.60119e+06m, -5.04198e+06m, 3.55488e+06m] (ITRF)
  
  Axis Coord Type      Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
  ------------------------------------------------------------------------------------------------ 
  0    0     Direction Right Ascension   SIN   256   64  15:22:00.000   128.00 -1.500000e+01 arcsec
  1    0     Direction Declination       SIN   256   64 +05.04.00.000   128.00  1.500000e+01 arcsec
  2    1     Stokes    Stokes                    1    1             I
  3    2     Spectral  Frequency                46    8   1.41279e+09     0.00 2.4414062e+04 Hz
                       Velocity                               1607.99     0.00 -5.152860e+00 km/s
##### End Task: imhead           
\end{verbatim}
\normalsize

If you choose {\tt mode='list'}, you get the summary in the logger and
a listing of keywords and values to the terminal:
\small
\begin{verbatim}
CASA <52>: imhead('ngc5921.demo.cleanimg.image',mode='list')
  Out[52]: 
{'beammajor': 52.378242492675781,
 'beamminor': 45.731891632080078,
 'beampa': -165.5721435546875,
 'bunit': 'Jy/beam',
 'cdelt1': '-7.27220521664e-05',
 'cdelt2': '7.27220521664e-05',
 'cdelt3': '1.0',
 'cdelt4': '24414.0625',
 'crpix1': 128.0,
 'crpix2': 128.0,
 'crpix3': 0.0,
 'crpix4': 0.0,
 'crval1': '4.02298392585',
 'crval2': '0.0884300154344',
 'crval3': 'I',
 'crval4': '1412787144.08',
 'ctype1': 'Right Ascension',
 'ctype2': 'Declination',
 'ctype3': 'Stokes',
 'ctype4': 'Frequency',
 'cunit1': 'rad',
 'cunit2': 'rad',
 'cunit3': '',
 'cunit4': 'Hz',
 'datamax': ' Not Known ',
 'datamin': -0.010392956435680389,
 'date-obs': '1995/04/13/00:00:00',
 'equinox': 'J2000',
 'imtype': 'Intensity',
 'masks': ' Not Known ',
 'maxpixpos': array([134, 134,   0,  38], dtype=int32),
 'maxpos': '15:21:53.976, +05.05.29.998, I, 1.41371e+09Hz',
 'minpixpos': array([117,   0,   0,  21], dtype=int32),
 'minpos': '15:22:11.035, +04.31.59.966, I, 1.4133e+09Hz',
 'object': 'N5921_2',
 'observer': 'TEST',
 'projection': 'SIN',
 'reffreqtype': 'LSRK',
 'restfreq': [1420405752.0],
 'telescope': 'VLA'}
\end{verbatim}
\normalsize
Note that this list is a return value and can be captured in a
variable:
\small
\begin{verbatim}
  mylist = imhead('ngc5921.demo.cleanimg.image',mode='list')
\end{verbatim}
\normalsize

The values for these keywords can be queried using {\tt mode='get'}.
At this point you should capture the return value:
\small
\begin{verbatim}
CASA <53>: mybmaj = imhead('ngc5921.demo.cleanimg.image',mode='get',hdkey='beammajor')

CASA <54>: mybmaj
  Out[54]: {'unit': 'arcsec', 'value': 52.378242492699997}

CASA <55>: myobserver = imhead('ngc5921.demo.cleanimg.image',mode='get',hdkey='observer')

CASA <56>: print myobserver
{'value': 'TEST', 'unit': ''}
\end{verbatim}
\normalsize

You can set the values for these keywords using
{\tt mode='put'}.  For example:
\small
\begin{verbatim}
CASA <57>: imhead('ngc5921.demo.cleanimg.image',mode='put',hdkey='observer',hdvalue='CASA')
  Out[57]: 'CASA'

CASA <58>: imhead('ngc5921.demo.cleanimg.image',mode='get',hdkey='observer')
  Out[58]: {'unit': '', 'value': 'CASA'}
\end{verbatim}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Continuum Subtraction on an Image Cube ({\tt imcontsub})}
\label{section:analysis.imcontsub}

One method to separate line and continuum emission in an image cube is
to specify a number of line-free channels in that cube, make a linear
fit to the visibilities in those channels, and subtract the fit from
the whole cube.  Note that the task {\tt uvcontsub} serves a similar
purpose; see \S~\ref{section:cal.other.uvcontsub} for a synopsis of
the pros and cons of either method.

The {\tt imcontsub} task will subtract a polynomial baseline fit to the
specified channels from an image cube.

The default inputs are: 
\small
\begin{verbatim}
#  imcontsub :: Continuum subtraction on images
imagename  =      ''   #  Name of the input image
linefile   =      ''   #  Output line image file name
contfile   =      ''   #  Output continuum image file name
fitorder   =       0   #  Polynomial order for the continuum estimation
region     =      ''   #  Image region or name to process see viewer
box        =      ''   #  Select one or more box regions
chans      =      ''   #  Select the channel(spectral) range
stokes     =      ''   #  Stokes params to image (I,IV,IQU,IQUV)
async      =   False   
\end{verbatim}
\normalsize

Area selection using {\tt box} and {\tt region} is detailed in 
\S~\ref{section:analysis.pars.box} and
\S~\ref{section:analysis.pars.regions} respectively.

Image cube plane selection using {\tt chans} and {\tt stokes}
are described in \S~\ref{section:analysis.pars.planes}.

{\bf ALERT:} {\tt imcontsub} has issues when the image does
not contain a spectral or stokes axis. Errors are generated when
run on an image missing one or both of these axes.  You will need
to use the Toolkit (e.g. the {\tt ia.adddegaxes} method) to add
degenerate missing axes to the image.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Examples for {\tt imcontsub})}
\label{section:analysis.imcontsub.examples}

The following uses the example images from NGC5921
(\S~\ref{section:scripts.ngc5921}).

First, we make a clean image without the uv-plane continuum
subtraction:
\small
\begin{verbatim}
  # First, run clearcal to clear the uvcontsub results from the
  # corrected column
  clearcal('ngc5921.demo.src.split.ms')
  
  # Now clean, keeping all the channels except first and last
  default('clean')
  vis = 'ngc5921.demo.src.split.ms'
  imagename = 'ngc5921.demo.nouvcontsub'
  mode = 'channel'
  nchan = 61
  start = 1
  width = 1
  imsize = [256,256]
  psfmode = 'clark'
  imagermode = ''
  cell = [15.,15.]
  niter = 6000
  threshold='8.0mJy'
  weighting = 'briggs'
  robust = 0.5
  mask = [108,108,148,148]
  interactive=False
  clean()
  
  # It will have made the image:
  # -----------------------------
  # ngc5921.demo.nouvcontsub.image

  # You can view this image
  viewer('ngc5921.demo.nouvcontsub.image')
\end{verbatim}
\normalsize
You can clearly see continuum sources in the image which were removed
previously in the script by the use of {\tt uvcontsub}.  Lets see
if {\tt imcontsub} can work as well.

Using the viewer, it looks like channels 0 through 4 and
50 through 60 are line-free.  Then:
\small
\begin{verbatim}
  default('imcontsub')
  imagename = 'ngc5921.demo.nouvcontsub.image'
  linefile  = 'ngc5921.demo.nouvcontsub.lineimage'
  contfile  = 'ngc5921.demo.nouvcontsub.contimage'
  fitorder  = 1
  chans      = '0~4,50~60'
  stokes    = 'I'
  imcontsub()
\end{verbatim}
\normalsize
This did not do too badly!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Image-plane Component Fitting ({\tt imfit})}
\label{section:analysis.imfit}

The inputs are:
\small
\begin{verbatim}
#  imfit :: Fit one or more elliptical Gaussian components on an image region(s)
imagename      =    ''   #  Name of the input image
box            =    ''   #  Specify one or more box regions for the fit.
region         =    ''   #  Region name or region specified using rg tool.
chan           =     0   #  Spectral channel on which to perform fit (only one may be specified).
stokes         =   'I'   #  Stokes parameter to fit.
mask           =    ''   #  Mask to be applied to the image
includepix     =    []   #  Range of pixel values to include for fitting.
excludepix     =    []   #  Range of pixel values to exclude for fitting.
residual       =    ''   #  Name of output residual image.
model          =    ''   #  Name of output model image.
estimates      =    ''   #  Name of file containing initial estimates of component parameters.
logfile        =    ''   #  Name of file to write fit results.
newestimates   =    ''   #  File to write fit results
async          = False   #  If true the taskname must be started using imfit(...)
\end{verbatim}
\normalsize
This task will return (as a Python dictionary) the results of the fit.

Note that to fit more than a single component, you {\em must} provide
starting estimates for each component via the {\tt estimates} file.
See {\tt ``help imfit''} for more details on this.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Examples for {\tt imfit}}
\label{section:analysis.imfit.examples}

The following are some examples using the B1608+656 Tutorial
\begin{quote}
  \url{http://casa.nrao.edu/Doc/Scripts/b1608_demo.py}
\end{quote}
as an example.

\small
\begin{verbatim}
# First fit only a single component at a time
# This is OK since the components are well-separated and not blended
# Box around component A
xfit_A_res = imfit('b1608.demo.clean2.image',box='121,121,136,136',
                   newestimates='b1608.demo.clean2.newestimate')

# Now extract the fit part of the return value
xfit_A = xfit_A_res['results']['component0']
#xfit_A
#  Out[7]: 
#{'flux': {'error': array([  6.73398035e-05,   0.00000000e+00,   0.00000000e+00,
#         0.00000000e+00]),
#          'polarisation': 'Stokes',
#          'unit': 'Jy',
#          'value': array([ 0.01753742,  0.        ,  0.        ,  0.        ])},
# 'label': '',
# 'shape': {'direction': {'error': {'latitude': {'unit': 'arcsec',
#                                                'value': 0.00041154866279462775},
#                                   'longitude': {'unit': 'arcsec',
#                                                 'value': 0.00046695916589535109}},
#                         'm0': {'unit': 'rad', 'value': -2.0541102061078207},
#                         'm1': {'unit': 'rad', 'value': 1.1439131060384089},
#                         'refer': 'J2000',
#                         'type': 'direction'},
#           'majoraxis': {'unit': 'arcsec', 'value': 0.29100166137741568},
#           'majoraxiserror': {'unit': 'arcsec',
#                              'value': 0.0011186420613222663},
#           'minoraxis': {'unit': 'arcsec', 'value': 0.24738110059830495},
#           'minoraxiserror': {'unit': 'arcsec',
#                              'value': 0.0013431999725066338},
#           'positionangle': {'unit': 'deg', 'value': 19.369249322401796},
#           'positionangleerror': {'unit': 'rad',
#                                  'value': 0.016663189295782171},
#           'type': 'Gaussian'},
# 'spectrum': {'frequency': {'m0': {'unit': 'GHz', 'value': 1.0},
#                            'refer': 'LSRK',
#                            'type': 'frequency'},
#              'type': 'Constant'}}

# Now the other components
xfit_B_res = imfit('b1608.demo.clean2.image',box='108,114,120,126',
                   newestimates='b1608.demo.clean2.newestimate',append=True)
xfit_B = xfit_B_res['results']['component0']

xfit_C_res= imfit('b1608.demo.clean2.image',box='108,84,120,96')
xfit_C = xfit_C_res['results']['component0']

xfit_D_res = imfit('b1608.demo.clean2.image',box='144,98,157,110')
xfit_D = xfit_D_res['results']['component0']

print ""
print "Imfit Results:"
print "--------------"
print "A  Flux = %6.4f Bmaj = %6.4f" % (xfit_A['flux']['value'][0],xfit_A['shape']['majoraxis']['value'])
print "B  Flux = %6.4f Bmaj = %6.4f" % (xfit_B['flux']['value'][0],xfit_B['shape']['majoraxis']['value'])
print "C  Flux = %6.4f Bmaj = %6.4f" % (xfit_C['flux']['value'][0],xfit_C['shape']['majoraxis']['value'])
print "D  Flux = %6.4f Bmaj = %6.4f" % (xfit_D['flux']['value'][0],xfit_D['shape']['majoraxis']['value'])
print ""
\end{verbatim}
\normalsize

Now try fitting four components together.  For this we will have to
provide an estimage file.  We will use the clean beam for the estimate
of the component sizes:
\small
\begin{verbatim}
estfile=open('b1608.demo.clean2.estimate','w')
print >>estfile,'# peak, x, y, bmaj, bmin, bpa'
print >>estfile,'0.017, 128, 129, 0.293arcsec, 0.238arcsec, 21.7deg'
print >>estfile,'0.008, 113, 120, 0.293arcsec, 0.238arcsec, 21.7deg'
print >>estfile,'0.008, 113,  90, 0.293arcsec, 0.238arcsec, 21.7deg'
print >>estfile,'0.002, 151, 104, 0.293arcsec, 0.238arcsec, 21.7deg'
estfile.close()
\end{verbatim}
\normalsize
Then, this can be used in {\tt imfit}:
\small
\begin{verbatim}
xfit_all_res = imfit('b1608.demo.clean2.image', 
                     estimates='b1608.demo.clean2.estimate',
                     logfile='b1608.demo.clean2.imfitall.log',
                     newestimates='b1608.demo.clean2.newestimate',
                     box='121,121,136,136,108,114,120,126,108,84,120,96,144,98,157,110')
# Now extract the fit part of the return values
xfit_allA = xfit_all_res['results']['component0']
xfit_allB = xfit_all_res['results']['component1']
xfit_allC = xfit_all_res['results']['component2']
xfit_allD = xfit_all_res['results']['component3']
\end{verbatim}
\normalsize
These results are almost identical to those from the individual fits.
You can see a nicer printout of the fit results in the logfile.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mathematical Operations on an Image ({\tt immath})}
\label{section:analysis.immath}

The inputs are:
\small
\begin{verbatim}
#  immath :: Perform math operations on images
imagename       =         ''          #  a list of input images
mode            = 'evalexpr'          #  mode for math operation (evalexpr, spix, pola, poli)
     expr       =         ''          #  Mathematical expression using images
     varnames   =         ''          #  a list of variable names to use with the image files

outfile         = 'immath_results.im' #  File where the output is saved
mask            =         ''          #  Mask to be applied to the images
region          =         ''          #  File path which contains an Image Region
box             =         ''          #  Select one or more box regions in the input images
chans           =         ''          #  Select the channel(spectral) range
stokes          =         ''          #  Stokes params to image (I,IV,IQU,IQUV)
async           =      False          #  If true the taskname must be started using immath(...)
\end{verbatim}
\normalsize

In all cases, {\tt outfile} must be supplied with the name of the
new output file to create.

The {\tt mode} parameter selects what {\tt immath} is to do.

The default {\tt mode='evalexpr'} lets the user specify a mathematical
operation to carry out on one or more input images.
The sub-parameter {\tt expr} contains the Lattice Expression Language
(LEL) string describing the image operations based on the images
in the {\tt imagename} parameter.
See \S~\ref{section:analysis.pars.lattice} for more on LEL strings
and the {\tt expr} parameter.

Mask specification is done using the {\tt mask} parameter.
This can optionally contain an on-the-fly
mask expression (in LEL) or point to an image with a pixel mask.
See \S~\ref{section:analysis.pars.mask} for more on the use of
the {\tt mask} parameter.  
See also \S~\ref{section:analysis.pars.lattice} for more on LEL strings.

Region selection is carried out through the {\tt region} and {\tt box}
parameters.
See \S~\ref{section:analysis.pars.box} and
\S~\ref{section:analysis.pars.regions} for more on area
selection.

Image plane selection is controlled by {\tt chans} and {\tt stokes}.
See \S~\ref{section:analysis.pars.planes} for details on plane
selction.

For {\tt mode='evalexpr'}, the standard usage for specifying images to
be used in the LEL expression is to provide them as a list in the {\tt imagename}
parameter, and then access there in the LEL expression by the
names {\tt IM0, IM1, ...}.  For example,
\small
\begin{verbatim}
immath(imagename=['image1.im','image2.im'],expr='IM0-IM1',outfile='ImageDiff.im')
\end{verbatim}
\normalsize
would subtract the second image given from the first.

For the special modes {\tt 'spix'}, {\tt 'pola'}, {\tt 'poli'}, the
required images for the given operation are to be provided in 
{\tt imagename} (some times in a particular order). 
{\bf V3.0 ALERT:} For {\tt mode='pola'} you MUST call as a function as
in the example below (\S~\ref{section:analysis.immath.examples.pol}), 
giving the parameters as arguments, or {\tt immath} will fail.

Detailed examples are given below.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Examples for {\tt immath}}
\label{section:analysis.immath.examples}

The following are examples using {\tt immath} using NGC5921 
(\S~\ref{section:scripts.ngc5921}).  Note that the image
names in the {\tt expr} are assumed to refer to existing image files
in the current working directory.

%%%%%%%
\subsubsection{Simple math}
\label{section:analysis.immath.examples.math}

Select a single plane (channel 22) of the 3-D cube and  
subtract it from the original image: 
\small
\begin{verbatim}
  immath(imagename='ngc5921.demo.cleanimg.image',
         expr='IM0',chans='22',
         outfile='ngc5921.demo.chan22.image')
\end{verbatim}
\normalsize

Double all values in our image:
\small
\begin{verbatim}
  immath(imagename=['ngc5921.demo.chan22.image'],
         expr='IM0*2.0',
         outfile='ngc5921.demo.chan22double.image' )
\end{verbatim}
\normalsize
    
Square all values in our image:
\small
\begin{verbatim}
  immath(imagename=['ngc5921.demo.chan22.image'],
         expr='IM0^2',
         outfile='ngc5921.demo.chan22squared.image' )
\end{verbatim}
\normalsize
Note that the units in the output image are still claimed to be
``Jy/beam'', ie.\ {\tt immath} will not correctly scale the units
in the image for non-linear cases like this.  Beware.

You can do other mathematical operations on an image (e.g.\
triginometric functions) as well as use scalars results from an image
(e.g.\ max, min, median, mean, variance).  You also have access to
constants such as {\tt e()} and {\tt pi()} (which are doubles
internally, while most images are floats). For example:
Take the sine of an image:
\small
\begin{verbatim}
  immath(imagename=['ngc5921.demo.chan22.image','ngc5921.demo.chan22squared.image'],
         expr='sin(float(pi())*IM0/sqrt(max(IM1)))',
         outfile='ngc5921.demo.chan22sine.image')
\end{verbatim}
\normalsize
Note again that the units are again kept as they were.
    
Select a single plane (channel 22) of the 3-D cube and  
subtract it from the original image: 
\small
\begin{verbatim}
  immath(imagename='ngc5921.demo.cleanimg.image',
         expr='IM0',chans='22',
         outfile='ngc5921.demo.chan22.image')

  immath(imagename=['ngc5921.demo.cleanimg.image','ngc5921.demo.chan22.image'],
         expr='IM0-IM1',
         outfile='ngc5921.demo.sub22.image')
\end{verbatim}
\normalsize
Note that in this example the 2-D plane gets expanded out and the
values are applied to each plane in the 3-D cube. 

%{\bf ALERT:} In the future this can be done without a temporary file, 
%using the {\tt INDEXIN()} function in the expression.
    
Select and save the inner 1/4 of an image for channels {\tt 40,42,44}
as well as channels 10 and below:
\small
\begin{verbatim}
   default('immath')
   imagename=['ngc5921.demo.cleanimg.image']
   expr='IM0'
   box='64,64,192,192'
   chans='<10;40,42,44'
   outfile='ngc5921.demo.inner.image'
   immath()
\end{verbatim}
\normalsize
{\bf ALERT:} Note that if chan selects more than one channel then
the output image has a number of channels given by the span from the
lowest and highest channel selected in {\tt chan}.  In the example 
above, it will have 45 channels.  The ones not selected will be masked
in the output cube.  If we had set
\small
\begin{verbatim}
   chans = '40,42,44'
\end{verbatim}
\normalsize
then there would be 5 output channels corresponding to channels
{\tt 40,41,42,43,44} of the MS with {\tt 41,43} masked.  Also, 
the {\tt chans='<10'} selects channels 0--9.

Note that the {\tt chans} syntax allows the operators {\tt '<'},
{\tt '<='}, {\tt '>'}, {\tt '>'}.  For example,
\small
\begin{verbatim}
   chans = '<17,>79'
   chans = '<=16,>=80'
\end{verbatim}
\normalsize
do the same thing.

Divide an image by another, with a threshold on one of the images:
\small
\begin{verbatim}
  immath(imagename=['ngc5921.demo.cleanimg.image','ngc5921.demo.chan22.image'],
         expr='IM0/IM1[IM1>0.008]',
         outfile='ngc5921.demo.div22.image')
\end{verbatim}
\normalsize

%%%%%%%
\subsubsection{Polarization manipulation}
\label{section:analysis.immath.examples.pol}

The following are some examples using the 3C129 Tutorial
\begin{quote}
  \url{http://casa.nrao.edu/Doc/Scripts/3c129_tutorial.py}
\end{quote}
as an example.

It is helpful to extract the Stokes planes from the cube
into individual images:
\small
\begin{verbatim}
   default('immath')
   imagename = '3C129BC.clean.image'
   outfile='3C129BC.I'; expr='IM0'; stokes='I'; immath();
   outfile='3C129BC.Q'; expr='IM0'; stokes='Q'; immath();
   outfile='3C129BC.U'; expr='IM0'; stokes='U'; immath();
   outfile='3C129BC.V'; expr='IM0'; stokes='V'; immath();
\end{verbatim}
\normalsize

Extract linearly polarized intensity and polarization position angle images:
\small
\begin{verbatim}
  immath(stokes='', outfile='3C129BC.P', mode='poli', 
         imagename=['3C129BC.Q','3C129BC.U'], sigma='0.0mJy/beam'); 
  immath(stokes='', outfile='3C129BC.X', mode='pola', 
         imagename=['3C129BC.Q','3C129BC.U'], sigma='0.0mJy/beam'); 
\end{verbatim}
\normalsize
{\bf V3.0 ALERT:} For {\tt mode='pola'} you MUST call as a function as
in this example (giving the parameters as arguments) or {\tt immath}
will fail.

Create a fractional linear polarization image:
\small
\begin{verbatim}
   default( 'immath')
   imagename = ['3C129BC.I','3C129BC.Q','3C129BC.U']
   outfile='3C129BC.fractional_linpol'
   expr='sqrt((IM1^2 + IM2^2)/IM0^2)'
   stokes=''
   immath()
\end{verbatim}
\normalsize

Create a polarized intensity image:
\small
\begin{verbatim}
   default( 'immath')
   imagename = ['3C129BC.Q','3C129BC.U','3C129BC.V']
   outfile='3C129BC.pol_intensity'
   expr='sqrt(IM0^2 + IM1^2 + IM2^2)'
   stokes=''
   immath()
\end{verbatim}
\normalsize

{\bf Toolkit Tricks:} The following uses the toolkit 
(\S~\ref{section:analysis.toolkit}).
You can make a complex linear polarization ($Q+iU$) image using the
{\tt imagepol} tool:
\small
\begin{verbatim}
  # See CASA User Reference Manual:
  # http://casa.nrao.edu/docs/casaref/imagepol-Tool.html
  #
  # Make an imagepol tool and open the clean image 
  potool = casac.homefinder.find_home_by_name('imagepolHome')
  po = potool.create()
  po.open('3C129BC.clean.image')
  # Use complexlinpol to make a Q+iU image
  po.complexlinpol('3C129BC.cmplxlinpol')
  po.close()
\end{verbatim}
\normalsize
You can now display this in the viewer, in particular overlay this
over the intensity raster with the intensity contours.  
When you load the image, use the LEL:
\small
\begin{verbatim}
  '3C129BC.cmplxlinpol'['3C129BC.P'>0.0001]
\end{verbatim}
\normalsize
which is entered into the LEL box at the bottom of the Load Data menu
(\S~\ref{section:display.viewerGUI.load}).

%%%%%%%
\subsubsection{Primary beam correction/uncorrection}
\label{section:analysis.immath.examples.pbcor}

In a script using {\tt mode='evalexpr'}, you might want to assemble
the string for {\tt expr} using string variables that contain
the names of files.  Since you need to include quotes inside the
{\tt expr} string, use a different quote outside (or escape the
string, e.g. {\tt '\''}.
For example, to do a primary beam correction on the NGC5921 cube,
\small
\begin{verbatim}
   imname = 'ngc5921.demo.cleanimg'
   imagename = imname
   ...
   clean()

   default('immath')
   clnimage = imname + '.image'
   fluximage = imname + '.flux'
   pbcorimage = imname + '.pbcor'

   outfile = pbcorimage
   imagename = [clnimage,fluximage]
   # cutoff at the 10% level
   expr='IM0/IM1[IM1>0.1]'

   immath()
\end{verbatim}
\normalsize
Note that we did not use a {\tt minpb} when we cleaned, so we use the
trick above to effectively set a cutoff in the primary beam 
{\tt .flux} image of 0.1.

For more on LEL strings, see AIPS++ Note 223 
\begin{quote}
   \url{http://aips2.nrao.edu/docs/notes/223/223.html}
\end{quote}
or in \S~\ref{section:analysis.pars.lattice} above.

%%%%%%%
\subsubsection{Spectral analysis}
\label{section:analysis.immath.examples.spec}

One can make an integrated 1-d spectrum over the whole image
by rebinning (integrating) over the two coordinate axes in
a specified region.
For example, using the NGC5921 image cube (with 46 channels):
\small
\begin{verbatim}
immath(outfile="ngc5921.demo.spectrum.all",mode="evalexpr",
       imagename='ngc5921.demo.clean.image',
       expr="rebin(IM0,[256,256,1,1])")
\end{verbatim}
\normalsize
The resulting image has shape {\tt [1,1,1,46]} as desired.
You can view this with the {\tt viewer} and will see a 1-D spectrum.

One can also do this with a box:
\small
\begin{verbatim}
immath(outfile="ngc5921.demo.spectrum.box",mode="evalexpr",
       imagename='ngc5921.demo.clean.image',
       expr="rebin(IM0,[256,256,1,1])",box="118,118,141,141")
\end{verbatim}
\normalsize
{\bf ALERT:} One cannot specify a {\tt region} without it collapsing the channel
axis (even when told to use all axes or channels).

{\bf Toolkit Tricks:} The following uses the toolkit (\S~\ref{section:analysis.toolkit}).
You can make an ascii file containing only the values (no other info
though):
\small
\begin{verbatim}
ia.open('ngc5921.demo.spectrum.all')
ia.toASCII('ngc5921.demo.spectrum.all.ascii')
\end{verbatim}
\normalsize
You can also extract to a record inside Python:
\small
\begin{verbatim}
myspec = ia.torecord()
\end{verbatim}
\normalsize
which you can then manipulate in Python.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using masks in {\tt immath}}
\label{section:analysis.immath.masks}

The {\tt mask} parameter is used inside {\tt immath} to apply a
mask to all the images used in {\tt expr} before calculations
are done (if you are curious, it uses the {\tt ia.subimage} tool
method to make virtual images that are then input in the LEL to the 
{\tt ia.imagecalc} method).

For example, lets assume that we have made a single channel image
using {\tt clean} for the NGC5921 data (see
Appendix~\ref{section:scripts.ngc5921}).
\small
\begin{verbatim}
  default('clean')
  
  vis = 'ngc5921.demo.src.split.ms.contsub'
  imagename = 'ngc5921.demo.chan22.cleanimg'
  mode = 'channel'
  nchan = 1
  start = 22
  step = 1
  
  field = ''
  spw = ''
  imsize = [256,256]
  cell = [15.,15.]
  psfalg = 'clark'
  gain = 0.1
  niter = 6000
  threshold='8.0mJy'
  weighting = 'briggs'
  rmode = 'norm'
  robust = 0.5
  
  mask = [108,108,148,148]
  
  clean()
\end{verbatim}
\normalsize
There is now a file {\tt 'ngc5921.demo.chan22.cleanimg.mask'} that is
an image with values 1.0 inside the {\tt cleanbox} region and 0.0
outside.  

We can use this to mask the clean image:
\small
\begin{verbatim}
  default('immath')
  imagename = 'ngc5921.demo.chan22.cleanimg.image'
  expr='IM0'
  mask='"ngc5921.demo.chan22.cleanimg.mask">0.5'
  outfile='ngc5921.demo.chan22.cleanimg.imasked'
  immath()
\end{verbatim}
\normalsize

{\bf Toolbox Tricks:}
Note that there are also {\it pixel masks} that can be contained in each
image.  These are Boolean masks, and are implicitly used in the
calculation for each image in {\tt expr}.  If you want to use the
mask in a different image not in {\tt expr}, try it in {\tt mask}:
\small
\begin{verbatim}
  # First make a pixel mask inside ngc5921.demo.chan22.cleanimg.mask
  ia.open('ngc5921.demo.chan22.cleanimg.mask')
  ia.calcmask('"ngc5921.demo.chan22.cleanimg.mask">0.5')
  ia.summary()
  ia.close()
  # There is now a 'mask0' mask in this image as reported by the summary

  # Now apply this pixel mask in immath
  default('immath')
  imagename='ngc5921.demo.chan22.cleanimg.image'
  expr='IM0'
  mask='mask(ngc5921.demo.chan22.cleanimg.mask)'
  outfile='ngc5921.demo.chan22.cleanimg.imasked1'
  immath()
\end{verbatim}
\normalsize

Note that nominally the axes of the mask must be congruent to the axes
of the images in {\tt expr}.  However, one exception is that the image
in {\tt mask} can have {\em fewer} axes (but not axes that exist but
are of the wrong lengths).  In this case {\tt immath} will extend the
missing axes to cover the range in the images in {\tt expr}.
Thus, you can apply a mask made from a single channel to a whole cube.
\small
\begin{verbatim}
  # drop degenerate stokes and freq axes from mask image
  ia.open('ngc5921.demo.chan22.cleanimg.mask')
  im2 = ia.subimage(outfile='ngc5921.demo.chan22.cleanimg.mymask',dropdeg=True)
  im2.summary()
  im2.close()
  ia.close()
  # mymask has only RA and Dec axes

  # Now apply this mask to the whole cube
  default('immath')
  imagename='ngc5921.demo.cleanimg.image'
  expr='IM0'
  mask='"ngc5921.demo.chan22.cleanimg.mymask">0.5'
  outfile='ngc5921.demo.cleanimg.imasked'
  immath()
\end{verbatim}
\normalsize

For more on masks as used in LEL, see
\begin{quote}
   \url{http://aips2.nrao.edu/docs/notes/223/223.html}
\end{quote}
or in \S~\ref{section:analysis.pars.mask} above.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computing the Moments of an Image Cube ({\tt immoments})}
\label{section:analysis.moments}

For spectral line datasets, the output of the imaging process is an
{\tt image cube}, with a frequency or velocity channel axis in
addition to the two sky coordinate axes.  This can be most easily
thought of as a series of image {\tt planes} stacked along the
spectral dimension.

A useful product to compute is to collapse the cube into a 
{\it moment} image by taking a linear combination of the individual
planes:
\begin{equation}
   M_m(x_i,y_i) = \sum_k^N w_m(x_i,y_i,v_k)\,I(x_i,y_i,v_k)
\end{equation}
for pixel $i$ and channel $k$ in the cube $I$.  There are a number
of choices to form the $m$ moment, usually approximating some
polynomial expansion of the intensity distribution over velocity
mean or sum, gradient, dispersion, skew, kurtosis, etc.).  There
are other possibilities (other than a weighted sum) for calculating
the image, such as median filtering, finding minima or maxima along
the spectral axis, or absolute mean deviations.  And the axis along
which to do these calculation need not be the spectral axis (ie.
do moments along Dec for a RA-Velocity image).  We will treat all
of these as generalized instances of a ``moment'' map.

The {\tt immoments} task will compute basic moment images from a cube.
The default inputs are:
\small
\begin{verbatim}
#  immoments :: Compute moments of an image cube:
imagename    =         ''   #   Input image name
moments      =        [0]   #  List of moments you would like to compute
axis         = 'spectral'   #  The momement axis: ra, dec, lat, long, spectral, or stokes
region       =         ''   #  Image Region.  Use viewer
box          =         ''   #  Select one or more box regions
chans        =         ''   #  Select the channel(spectral) range
stokes       =         ''   #  Stokes params to image (I,IV,IQU,IQUV)
mask         =         ''   #  mask used for selecting the area of the image to calculate the moments on
includepix   =         -1   #  Range of pixel values to include
excludepix   =         -1   #  Range of pixel values to exclude
outfile      =         ''   #  Output image file name (or root for multiple moments)
async        =      False   #  If true the taskname must be started using immoments(...)
\end{verbatim}
\normalsize

This task will operate on the input file given by {\tt imagename} and
produce a new image or set of images based on the name given in
{\tt outfile}.

The {\tt moments} parameter chooses which moments are calculated.
The choices for the operation mode are:
\small
\begin{verbatim}
    moments=-1  - mean value of the spectrum
    moments=0   - integrated value of the spectrum
    moments=1   - intensity weighted coordinate;traditionally used to get 
                  'velocity fields'
    moments=2   - intensity weighted dispersion of the coordinate; traditionally
                  used to get 'velocity dispersion'
    moments=3   - median of I
    moments=4   - median coordinate
    moments=5   - standard deviation about the mean of the spectrum
    moments=6   - root mean square of the spectrum
    moments=7   - absolute mean deviation of the spectrum
    moments=8   - maximum value of the spectrum
    moments=9   - coordinate of the maximum value of the spectrum
    moments=10  - minimum value of the spectrum
    moments=11  - coordinate of the minimum value of the spectrum
\end{verbatim}
\normalsize
The meaning of these is described in the CASA Reference Manual:
\begin{quote}
   \url{http://casa.nrao.edu/docs/casaref/image.moments.html}
\end{quote}

The {\tt axis} parameter sets the axis along which the moment is
``collapsed'' or calculated.  Choices are: 
{\tt 'ra'}, {\tt 'dec'}, {\tt 'lat'}, {\tt 'long'}, {\tt 'spectral'},
or {\tt 'stokes'}.  A standard moment-0 or moment-1 image of
a spectral cube would use the default choice {\tt 'spectral'}.
One could make a position-velocity map by setting {\tt 'ra'} or 
{\tt 'dec'}.

The {\tt includepix} and {\tt excludepix} parameters are used to set
ranges for the inclusion and exclusion of pixels based on values.
For example, {\tt includepix=[0.05,100.0]} will include pixels
with values from 50~mJy to 1000~Jy, and 
{\tt excludepix=[100.0,1000.0]} will exclude pixels with values
from 100 to 1000~Jy.

If a single moment is chosen, the {\tt outfile} specifies the exact
name of the output image.  If multiple {\tt moments} are chosen,
then {\tt outfile} will be used as the root of the output filenames,
which will get different suffixes for each moment.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hints for using ({\tt immoments})}
\label{section:analysis.moments.hints}

In order to make an unbiased moment-0 image, do not put in 
any thresholding using {\tt includepix} or {\tt excludepix}.
This is so that the (presumably) zero-mean noise fluctuations
in off-line parts of the image cube will cancel out.  If you
image has large biases, like a pronounced clean bowl due to
missing large-scale flux, then your moment-0 image will be biased
also.  It will be difficult to alleviate this with a threshold,
but you can try.

To make a usable moment-1 (or higher) image, on the other hand,
it is critical to set a
reasonable threshold to exclude noise from being added to the
moment maps.  Something like a few times the rms noise level
in the usable planes seems to work (put into {\tt includepix}
or {\tt excludepix} as needed.  Also use {\tt chans} to ignore
channels with bad data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Examples using ({\tt immoments})}
\label{section:analysis.moments.example}

For example, using the NGC5921 example (\S~\ref{section:scripts.ngc5921}):
\small
\begin{verbatim}
  default('immoments')
  imagename = 'ngc5921.demo.cleanimg'
  # Do first and second spectral moments
  axis  = 'spectral'
  chans = ''
  moments = [0,1]
  # Need to mask out noisy pixels, currently done
  # using hard global limits
  excludepix = [-100,0.009]
  outfile = 'ngc5921.demo.moments'
  
  immoments()
  
  # It will have made the images:
  # --------------------------------------
  # ngc5921.demo.moments.integrated
  # ngc5921.demo.moments.weighted_coord
\end{verbatim}
\normalsize

Other examples of NGC2403 (a moment zero image of a VLA line dataset)
and NGC4826 (a moment one image of a BIMA CO line dataset) are
shown in Figure~\ref{fig:n2403momzero}.

\begin{figure}[h!]
\begin{center}
\pngname{n2403mom0}{3.15}
\pngname{n4826mom1}{3.30}
\caption{\label{fig:n2403momzero} NGC2403 VLA moment zero (left) and
NGC4826 BIMA moment one (right) images as shown in the {\tt viewer}.}
\hrulefill
\end{center}
\end{figure}

{\bf ALERT:} We are working on improving the thresholding
of planes beyond the global cutoffs in {\tt includepix}
and {\tt excludepix}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computing image statistics ({\tt imstat})}
\label{section:analysis.imstat}

The {\tt imstat} task will calculate statistics on a region of
an image, and return the results as a return value in a Python
dictionary.

The inputs are:
\small
\begin{verbatim}
#  imstat :: Displays statistical information on an image or image region
imagename  =      ''   #  Name of the input image
region     =      ''   #  Image Region or name. Use Viewer
box        =      ''   #  Select one or more box regions
chans      =      ''   #  Select the channel(spectral) range
stokes     =      ''   #  Stokes params to image (I,IV,IQU,IQUV)
async      =   False       
\end{verbatim}
\normalsize

Area selection using {\tt box} and {\tt region} is detailed in 
\S~\ref{section:analysis.pars.box} and
\S~\ref{section:analysis.pars.regions} respectively.

Plane selection is controlled by {\tt chans} and {\tt stokes}.
See \S~\ref{section:analysis.pars.planes} for details on plane
selction.

{\bf ALERT:} As with {\tt imcontsub}, if the image is missing one
or more of the stokes and spectral axes, then {\tt imstat} will fail.  
See the discussion of the workaround for this in
\S~\ref{section:analysis.imcontsub}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using the task return value}
\label{section:analysis.imstat.xstat}

The contents of the return value of {\tt imstat} are in a Python
dictionary of key-value sets.  For example,
\small
\begin{verbatim}
   xstat = imstat()
\end{verbatim}
\normalsize
will assign this to the Python variable {\tt xstat}.

The keys for {\tt xstat} are then:
\small
\begin{verbatim}
   KEYS
   blc          - absolute PIXEL coordinate of the bottom left corner of 
                  the bounding box surrounding the selected region
   blcf         - Same as blc, but uses WORLD coordinates instead of pixels
   trc          - the absolute PIXEL coordinate of the top right corner 
                  of the bounding box surrounding the selected region
   trcf         - Same as trc, but uses WORLD coordinates instead of pixels
   flux         - the integrated flux density if the beam is defined and 
                  the if brightness units are $Jy/beam$
   npts         - the number of unmasked points used
   max          - the maximum pixel value
   min          - minimum pixel value
   maxpos       - absolute PIXEL coordinate of maximum pixel value
   maxposf      - Same as maxpos, but uses WORLD coordinates instead of pixels
   minpos       - absolute pixel coordinate of minimum pixel value
   minposf      - Same as minpos, but uses WORLD coordinates instead of pixels
   sum          - the sum of the pixel values: $\sum I_i$
   sumsq        - the sum of the squares of the pixel values: $\sum I_i^2$
   mean         - the mean of pixel values: 
                  ar{I} = \sum I_i / n$
   sigma        - the standard deviation about the mean: 
                  $\sigma^2 = (\sum I_i -ar{I})^2 / (n-1)$
   rms          - the root mean square: 
                  $\sqrt {\sum I_i^2 / n}$
   median       - the median pixel value (if robust=T)
   medabsdevmed - the median of the absolute deviations from the 
                  median (if robust=T)    
   quartile     - the inter-quartile range (if robust=T). Find the points 
                  which are 25% largest and 75% largest (the median is 
                  50% largest), find their difference and divide that 
                  difference by 2.
\end{verbatim}
\normalsize

For example, an {\tt imstat} call might be
\small
\begin{verbatim}
   default('imstat')
   imagename = 'ngc5921.demo.cleanimg.image'  #  The NGC5921 image cube
   box       = '108,108,148,148'              #  20 pixels around the center
   chans     = '21'                           #  channel 21

   xstat = imstat()
\end{verbatim}
\normalsize

In the terminal window, {\tt imstat} reports:
\small
\begin{verbatim}
Statistics on  ngc5921.usecase.clean.image

Region ---
   -- bottom-left corner (pixel) [blc]: [108, 108, 0, 21]
   -- top-right corner (pixel) [trc]:   [148, 148, 0, 21]
   -- bottom-left corner (world) [blcf]: 15:22:20.076, +04.58.59.981, I, 1.41332e+09Hz
   -- top-right corner( world) [trcf]: 15:21:39.919, +05.08.59.981, I, 1.41332e+09Hz

Values --
   -- flux [flux]:              0.111799236126
   -- number of points [npts]:  1681.0
   -- maximum value [max]:      0.029451508075
   -- minimum value [min]:     -0.00612453464419
   -- position of max value (pixel) [maxpos]:  [124, 131, 0, 21]
   -- position of min value (pixel) [minpos]:  [142, 110, 0, 21]
   -- position of max value (world) [maxposf]: 15:22:04.016, +05.04.44.999, I, 1.41332e+09Hz
   -- position of min value (world) [minposf]: 15:21:45.947, +04.59.29.990, I, 1.41332e+09Hz
   -- Sum of pixel values [sum]: 1.32267159822
   -- Sum of squared pixel values [sumsq]: 0.0284534543692
   
Statistics ---
   -- Mean of the pixel values [mean]:       0.000786836167885
   -- Standard deviation of the Mean [sigma]: 0.00403944306904
   -- Root mean square [rms]:               0.00411418313161
   -- Median of the pixel values [median]:     0.000137259965413
   -- Median of the deviations [medabsdevmed]:       0.00152346317191
   -- Quartile [quartile]:                       0.00305395200849

\end{verbatim}
\normalsize
The return value in {\tt xstat} is
\small
\begin{verbatim}
CASA <152>: xstat
  Out[152]: 
{'blc': array([108, 108,   0,  21]),
 'blcf': '15:22:20.076, +04.58.59.981, I, 1.41332e+09Hz',
 'flux': array([ 0.11179924]),
 'max': array([ 0.02945151]),
 'maxpos': array([124, 131,   0,  21]),
 'maxposf': '15:22:04.016, +05.04.44.999, I, 1.41332e+09Hz',
 'mean': array([ 0.00078684]),
 'medabsdevmed': array([ 0.00152346]),
 'median': array([ 0.00013726]),
 'min': array([-0.00612453]),
 'minpos': array([142, 110,   0,  21]),
 'minposf': '15:21:45.947, +04.59.29.990, I, 1.41332e+09Hz',
 'npts': array([ 1681.]),
 'quartile': array([ 0.00305395]),
 'rms': array([ 0.00411418]),
 'sigma': array([ 0.00403944]),
 'sum': array([ 1.3226716]),
 'sumsq': array([ 0.02845345]),
 'trc': array([148, 148,   0,  21]),
 'trcf': '15:21:39.919, +05.08.59.981, I, 1.41332e+09Hz'}
\end{verbatim}
\normalsize

{\bf ALERT:} The return dictionary currently includes 
NumPy {\tt array} values, which have to be accessed by
an array index to get the array value.
To access these dictionary elements, use the standard Python
dictionary syntax, e.g.
\small
\begin{verbatim}
     xstat[<key string>][<array index>]
\end{verbatim}
\normalsize
For example, to extract the standard deviation as a number
\small
\begin{verbatim}
   mystddev = xstat['sigma'][0]
   print 'Sigma = '+str(xstat['sigma'][0])
\end{verbatim}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Examples for {\tt imstat})}
\label{section:analysis.imstat.examples}

The following are some examples using the B1608+656 Tutorial
\begin{quote}
  \url{http://casa.nrao.edu/Doc/Scripts/b1608_demo.py}
\end{quote}
as an example.

To extract statistics for the final image:
\small
\begin{verbatim}
   xstat = imstat('b1608.demo.clean2.image')
# Printing out some of these
   print 'Max   = '+str(xstat['max'][0])
   print 'Sigma = '+str(xstat['sigma'][0])
# results:
# Max   = 0.016796965152
# Sigma = 0.00033631979385
\end{verbatim}
\normalsize

In a box around the brightest component:
\small
\begin{verbatim}
   xstat_A = imstat('b1608.demo.clean2.image',box='124,125,132,133')
# Printing out some of these
   print 'Comp A Max Flux = '+str(xstat_A['max'][0])
   print 'Comp A Max X,Y  = ('+str(xstat_A['maxpos'][0])+','+str(xstat_A['maxpos'][1])+')'
# results:
# Comp A Max Flux = 0.016796965152
# Comp A Max X,Y  = (128,129)
\end{verbatim}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extracting data from an image ({\tt imval})}
\label{section:analysis.imval}

The {\tt imval} task will extract the values of the data and mask
from a specified region of an image and place in the task return
value as a Python dictionary.

The inputs are:
\small
\begin{verbatim}
#  imval :: Get the data value(s) and/or mask value in an image.
imagename  =      ''   #  Name of the input image
region     =      ''   #  Image Region.  Use viewer
box        =      ''   #  Select one or more box regions
chans      =      ''   #  Select the channel(spectral) range
stokes     =      ''   #  Stokes params to image (I,IV,IQU,IQUV)
async      =   False       
\end{verbatim}
\normalsize

Area selection using {\tt box} and {\tt region} is detailed in 
\S~\ref{section:analysis.pars.box} and
\S~\ref{section:analysis.pars.regions} respectively.
By default, {\tt box=''} will
extract the image information at the reference pixel on the
direction axes.

Plane selection is controlled by {\tt chans} and {\tt stokes}.
See \S~\ref{section:analysis.pars.planes} for details on plane
selction.  By default, {\tt chans=''} and {\tt stokes=''} will
extract the image information in all channels and Stokes planes.

For instance,
\small
\begin{verbatim}
   xval = imval('myimage', box='144,144', stokes='I' )
\end{verbatim}
\normalsize
will extract the Stokes I value or spectrum at pixel 144,144, while
\small
\begin{verbatim}
   xval = imval('myimage', box='134,134.154,154', stokes='I' )
\end{verbatim}
\normalsize
will extract a 21 by 21 pixel region.

Extractions are returned in NumPy arrays in the return value
dicionary, plus some extra elements describing the axes and selection:
\small
\begin{verbatim}
CASA <2>: xval = imval('ngc5921.demo.moments.integrated')

CASA <3>: xval
  Out[3]: 
{'axes': [[0, 'Right Ascension'],
          [1, 'Declination'],
          [3, 'Frequency'],
          [2, 'Stokes']],
 'blc': [128, 128, 0, 0],
 'data': array([ 0.89667124]),
 'mask': array([ True], dtype=bool),
 'trc': [128, 128, 0, 0],
 'unit': 'Jy/beam.km/s'}
\end{verbatim}
\normalsize
extracts the reference pixel value in this 1-plane image.  Note that
the {\tt 'data'} and {\tt 'mask'} elements are NumPy arrays, not 
Python lists.

To extract a spectrum from a cube:
\small
\begin{verbatim}
CASA <8>: xval = imval('ngc5921.demo.clean.image',box='125,125')

CASA <9>: xval
  Out[9]: 
{'axes': [[0, 'Right Ascension'],
          [1, 'Declination'],
          [3, 'Frequency'],
          [2, 'Stokes']],
 'blc': [125, 125, 0, 0],
 'data': array([  8.45717848e-04,   1.93370355e-03,   1.53750915e-03,
         2.88399984e-03,   2.38683447e-03,   2.89159478e-04,
         3.16268904e-03,   9.93389636e-03,   1.88773088e-02,
         3.01138610e-02,   3.14478502e-02,   4.03211266e-02,
         3.82498614e-02,   3.06552909e-02,   2.80734301e-02,
         1.72479432e-02,   1.20884273e-02,   6.13593217e-03,
         9.04005766e-03,   1.71429547e-03,   5.22095338e-03,
         2.49114982e-03,   5.30831399e-04,   4.80734324e-03,
         1.19265869e-05,   1.29435991e-03,   3.75700940e-04,
         2.34788167e-03,   2.72604497e-03,   1.78467855e-03,
         9.74952069e-04,   2.24676146e-03,   1.82263291e-04,
         1.98463408e-06,   2.02975096e-03,   9.65532148e-04,
         1.68218743e-03,   2.92119570e-03,   1.29359076e-03,
        -5.11484570e-04,   1.54162932e-03,   4.68662125e-04,
        -8.50282842e-04,  -7.91683051e-05,   2.95954203e-04,
        -1.30133145e-03]),
 'mask': array([ True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,  True], dtype=bool),
 'trc': [125, 125, 0, 45],
 'unit': 'Jy/beam'}
\end{verbatim}
\normalsize

To extract a region from the plane of a cube:
\small
\begin{verbatim}
CASA <13>: xval = imval('ngc5921.demo.clean.image',box='126,128,130,129',chans='23')

CASA <14>: xval
  Out[14]: 
{'axes': [[0, 'Right Ascension'],
          [1, 'Declination'],
          [3, 'Frequency'],
          [2, 'Stokes']],
 'blc': [126, 128, 0, 23],
 'data': array([[ 0.00938627,  0.01487772],
       [ 0.00955847,  0.01688832],
       [ 0.00696965,  0.01501907],
       [ 0.00460964,  0.01220793],
       [ 0.00358087,  0.00990202]]),
 'mask': array([[ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True]], dtype=bool),
 'trc': [130, 129, 0, 23],
 'unit': 'Jy/beam'}

CASA <15>: print xval['data'][0][1]
0.0148777160794
\end{verbatim}
\normalsize
In this example, a rectangular box was extracted, and you can see the
order in the array and how to address specific elements.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Regridding an Image ({\tt imregrid})}
\label{section:analysis.regrid}

\begin{wrapfigure}{r}{2.5in}
  \begin{boxedminipage}{2.5in}
     \centerline{\bf Inside the Toolkit:}
     More complex coordinate system and image regridding 
     operation can be carried out in the toolkit.  The 
     {\tt coordsys} ({\tt cs}) tool and the {\tt ia.regrid}
     method are the relevant components.
  \end{boxedminipage}
\end{wrapfigure}

It is occasionally necessary to regrid an image onto a new coordinate
system.  The {\tt imregrid} task will regrid one image onto the
coordinate system of another, creating an output image.  In this
task, the user need only specify the names of the input, template, and
output images.  

If the user needs to do more complex operations, such as regridding an
image onto an arbitrary (but known) coordinate system, changing from
Equatorial to Galactic coordinates, or precessing Equinoxes, the CASA
toolkit can be used (see sidebox).  Some of these facilities will
eventually be provided in task form.

The default inputs are:
\small
\begin{verbatim}
#  imregrid :: regrid an image onto a template image
imagename           =         ''        #  Name of input image
template            =         ''        #  Name of reference image
output              =         ''        #  Name of output regridded image
async               =      False        #  
\end{verbatim}
\normalsize
The {\tt output} image will have the data in {\tt imagename} regridded
onto the coordinate system of {\tt template} image.

{\bf ALERT:} The {\tt imregrid} task is currently under test
againt similar AIPS tasks and we are looking to improve its
performance. Future releases will enable regridding without the need
for a template image.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Image Convolution({\tt imsmooth})}
\label{section:analysis.imsmooth}

The default inputs are:
\small
\begin{verbatim}
#  imsmooth :: Smooth an image or portion of an image
imagename   =       ''   #  Name of the input image
kernel      = 'boxcar'   #  Type of kernel to use: gaussian or boxcar.
region      =       ''   #  Image Region or name.  Use viewer
box         =       ''   #  Select one or more box regions
chans       =       ''   #  Select the channel(spectral) range
stokes      =       ''   #  Stokes params to image (I,IV,IQU,IQUV)
mask        =       ''   #  mask used for selecting the area of the image to smooth
outfile     =       ''   #  Output, smoothed, image file name
async       =    False   #
\end{verbatim}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Image Import/Export to FITS}
\label{section:analysis.fits}

These tasks will allow you to write your CASA image to a FITS file
that other packages can read, and to import existing FITS files
into CASA as an image.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{FITS Image Export ({\tt exportfits})}
\label{section:analysis.fits.export}

To export your images to fits format use the {\tt exportfits} task.
The inputs are:
\small
\begin{verbatim}
#  exportfits :: Convert a CASA image to a FITS file
imagename    =         ''   #  Name of input CASA image
fitsimage    =         ''   #  Name of output image FITS file
velocity     =      False   #  Use velocity (rather than frequency) as spectral axis
optical      =      False   #  Use the optical (rather than radio) velocity convention
bitpix       =        -32   #  Bits per pixel
minpix       =          0   #  Minimum pixel value
maxpix       =          0   #  Maximum pixel value
overwrite    =      False   #  Overwrite pre-existing imagename
dropstokes   =      False   #  Drop the Stokes axis?
stokeslast   =       True   #  Put Stokes axis last in header?
async        =      False   #  If true the taskname must be started using exportfits(...)
\end{verbatim}
\normalsize

The {\tt dropstokes} or {\tt stokeslast} parameter may be needed to
make the FITS image compatible with an external application.

For example,
\small
\begin{verbatim}
   exportfits('ngc5921.demo.cleanimg.image','ngc5921.demo.cleanimg.image.fits')
\end{verbatim}
\normalsize

%{\bf ALERT:} Setting {\tt async=True} is recommended because
%there is a flaw in this version of the FITS classes that will
%cause subsequent FITS import ({\tt importfits} or {\tt importuvfits})
%after an export to fail.  Using asynchronous export will circumvent
%this by forcing the creation and use of a new tool object rather than
%using default one.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{FITS Image Import ({\tt importfits})}
\label{section:analysis.fits.import}

You can also use the {\tt importfits} task to import a FITS image into
CASA image table format.  Note, the CASA {\tt viewer} can read fits
images so you don't need to do this if you just want to look a the image.  
The inputs for {\tt importfits} are:
\small
\begin{verbatim}
#  importfits :: Convert an image FITS file into a CASA image:

fitsimage    =         ''   #   Name of input image FITS file
imagename    =         ''   #   Name of output CASA image
whichrep     =          0   #   Which coordinate representation (if multiple)
whichhdu     =          0   #   Which image (if multiple)
zeroblanks   =       True   #   If blanked fill with zeros (not NaNs)
overwrite    =      False   #   Overwrite pre-existing imagename
async        =      False   #   if True run in the background, prompt is freed
\end{verbatim}
\normalsize
For example, we can read the above image back in
\small
\begin{verbatim}
  importfits('ngc5921.demo.cleanimg.image.fits','ngc5921.demo.cleanimage')
\end{verbatim}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using the CASA Toolkit for Image Analysis}
\label{section:analysis.toolkit}

\begin{wrapfigure}{r}{2.5in}
  \begin{boxedminipage}{2.5in}
     \centerline{\bf Inside the Toolkit:}
     The image analysis tool ({\tt ia}) is the workhorse here.
     It appears in the User Reference Manual as the {\tt image}
     tool.  Other relevant tools for analysis and manipulation
     include {\tt measures} ({\tt me}), {\tt quanta} ({\tt qa})
     and {\tt coordsys} ({\tt cs}).
  \end{boxedminipage}
\end{wrapfigure}

Although this cookbook is aimed at general users employing the
tasks, we include here a more detailed description of doing
image analysis in the CASA toolkit.  This is because
there are currently only a few tasks geared towards image analysis,
as well as due to the breadth of possible manipulations that the
toolkit allows that more sophisticated users will appreciate.

To see a list of the {\tt ia} methods available, use the 
CASA {\tt help} command:
\small
\begin{verbatim}
CASA <1>: help ia 
--------> help(ia)
Help on image object:

class image(__builtin__.object)
 |  image object
 |  
 |  Methods defined here:
 |  
 |  __init__(...)
 |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
 |  
 |  __str__(...)
 |      x.__str__() <==> str(x)
 |  
 |  adddegaxes(...)
 |      Add degenerate axes of the specified type to the image`  : 
 |        outfile
 |        direction = false
 |        spectral  = false
 |        stokes
 |        linear    = false
 |        tabular   = false
 |        overwrite = false
 |      ----------------------------------------
 |  
 |  addnoise(...)

...

 |  
 |  unlock(...)
 |      Release any lock on the image`  : 
 |      ----------------------------------------
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __new__ = <built-in method __new__ of type object at 0x55d0f20>
 |      T.__new__(S, ...) -> a new object with type S, a subtype of T

\end{verbatim}
\normalsize
or for a compact listing use {\tt <TAB>} completion on {\tt ia.},
e.g.
\small
\begin{verbatim}
CASA <2>: ia.
Display all 101 possibilities? (y or n)
ia.__class__                ia.fitsky                   ia.newimagefromshape
ia.__delattr__              ia.fromarray                ia.open
ia.__doc__                  ia.fromascii                ia.outputvariant
ia.__getattribute__         ia.fromfits                 ia.pixelvalue
ia.__hash__                 ia.fromforeign              ia.putchunk
ia.__init__                 ia.fromimage                ia.putregion
ia.__new__                  ia.fromshape                ia.rebin
ia.__reduce__               ia.getchunk                 ia.regrid
ia.__reduce_ex__            ia.getregion                ia.remove
ia.__repr__                 ia.getslice                 ia.removefile
ia.__setattr__              ia.hanning                  ia.rename
ia.__str__                  ia.haslock                  ia.replacemaskedpixels
ia.adddegaxes               ia.histograms               ia.restoringbeam
ia.addnoise                 ia.history                  ia.rotate
ia.boundingbox              ia.imagecalc                ia.sepconvolve
ia.brightnessunit           ia.imageconcat              ia.set
ia.calc                     ia.insert                   ia.setboxregion
ia.calcmask                 ia.isopen                   ia.setbrightnessunit
ia.close                    ia.ispersistent             ia.setcoordsys
ia.continuumsub             ia.lock                     ia.sethistory
ia.convertflux              ia.makearray                ia.setmiscinfo
ia.convolve                 ia.makecomplex              ia.setrestoringbeam
ia.convolve2d               ia.maketestimage            ia.shape
ia.coordmeasures            ia.maskhandler              ia.statistics
ia.coordsys                 ia.maxfit                   ia.subimage
ia.decompose                ia.miscinfo                 ia.summary
ia.deconvolvecomponentlist  ia.modify                   ia.toASCII
ia.done                     ia.moments                  ia.tofits
ia.echo                     ia.name                     ia.topixel
ia.fft                      ia.newimage                 ia.toworld
ia.findsources              ia.newimagefromarray        ia.twopointcorrelation
ia.fitallprofiles           ia.newimagefromfile         ia.type
ia.fitpolynomial            ia.newimagefromfits         ia.unlock
ia.fitprofile               ia.newimagefromimage        
\end{verbatim}
\normalsize

A common use of the {\tt ia} tool is to do region statistics on
an image.  The {\tt imhead} task has {\tt mode='stats'} to do
this quickly over the entire image cube.  The tool can do this
on specific planes or sub-regions.  For example, in the Jupiter
6cm example script (\S~\ref{section:scripts.jupiter}), 
the {\tt ia} tool is used to get on-source and off-source statistics
for regression:
\small
\begin{verbatim}
# The variable clnimage points to the clean image name

# Pull the max and rms from the clean image
ia.open(clnimage)
on_statistics=ia.statistics()
thistest_immax=on_statistics['max'][0]
oldtest_immax = 1.07732224464
print ' Clean image ON-SRC max should be ',oldtest_immax
print ' Found : Max in image = ',thistest_immax
diff_immax = abs((oldtest_immax-thistest_immax)/oldtest_immax)
print ' Difference (fractional) = ',diff_immax

print ''
# Now do stats in the lower right corner of the image
box = ia.setboxregion([0.75,0.00],[1.00,0.25],frac=true)
off_statistics=ia.statistics(region=box)
thistest_imrms=off_statistics['rms'][0]
oldtest_imrms = 0.0010449
print ' Clean image OFF-SRC rms should be ',oldtest_imrms
print ' Found : rms in image = ',thistest_imrms
diff_imrms = abs((oldtest_imrms-thistest_imrms)/oldtest_imrms)
print ' Difference (fractional) = ',diff_imrms

print ''
print ' Final Clean image Dynamic Range = ',thistest_immax/thistest_imrms
print ''
print ' =============== '

ia.close()

\end{verbatim}
\normalsize

{\bf ALERT:} Bad things can happen if you open some tools,
like {\tt ia}, in the Python command line on files and forget to
close them before running scripts that use the 
{\tt os.system('rm -rf <filename>)} call to clean up.  We are 
in the process of cleaning up cases like this where there can
be stale handles on files that have been manually deleted, but
for the meantime be warned that you might get exceptions
(usually of the ``{\tt SimpleOrderedMap-remove}'' flavor, or 
even Segmentation Faults and core-dumps!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples of CASA Image Analysis}
\label{section:analysis.examples}

See the scripts provied in Appendix~\ref{chapter:scripts} for examples of
data and image analysis.  In particular, we refer
the interested user to the demonstrations for:
\begin{itemize}
\item NGC5921 (VLA HI) --- a quick demo of basic CASA spectral line analyis
      (\ref{section:scripts.ngc5921})
\item Jupiter (VLA 6cm continuum polarimetry) --- polarization image analysis
      (\ref{section:scripts.jupiter})
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
